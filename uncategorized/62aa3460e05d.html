<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"andornot.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp","menu_item":"fadeInDown"}},"path":"search.xml"};
  </script>

  <meta name="description" content="虽然博客已经有了分类和标签功能，但是仍显得非常杂乱。 在此对重要的知识点做一个整合，方便随时复习回顾。 如有问题建议，请联系andornottop@163.com。">
<meta property="og:type" content="article">
<meta property="og:title" content="与或非的进阶之路">
<meta property="og:url" content="https://andornot.top/uncategorized/62aa3460e05d.html">
<meta property="og:site_name" content="与或非&#39;s Blog">
<meta property="og:description" content="虽然博客已经有了分类和标签功能，但是仍显得非常杂乱。 在此对重要的知识点做一个整合，方便随时复习回顾。 如有问题建议，请联系andornottop@163.com。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/%E5%8D%9A%E5%AE%A2andornot.top.png">
<meta property="og:image" content="https://andornotblog.oss-cn-beijing.aliyuncs.com/imgs/summary1.png">
<meta property="og:image" content="https://andornotblog.oss-cn-beijing.aliyuncs.com/imgs/summary2.png">
<meta property="og:image" content="https://andornotblog.oss-cn-beijing.aliyuncs.com/imgs/summary3.png">
<meta property="article:published_time" content="2021-05-31T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-08T11:34:54.191Z">
<meta property="article:author" content="与或非">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/%E5%8D%9A%E5%AE%A2andornot.top.png">

<link rel="canonical" href="https://andornot.top/uncategorized/62aa3460e05d.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>与或非的进阶之路 | 与或非's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">与或非's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://andornot.top/uncategorized/62aa3460e05d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="与或非">
      <meta itemprop="description" content="个人成长记录与分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="与或非's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          与或非的进阶之路
        </h1>

        <div class="post-meta">
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-06-01T00:00:00+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 19:34:54" itemprop="dateModified" datetime="2023-04-08T19:34:54+08:00">2023-04-08</time>
              </span>
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>虽然博客已经有了分类和标签功能，但是仍显得非常杂乱。</p>
<p>在此对重要的知识点做一个整合，方便随时复习回顾。</p>
<p>如有问题建议，请联系<a href="mailto:andornottop@163.com">andornottop@163.com</a>。</p>
<span id="more"></span>

<p><img src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/%E5%8D%9A%E5%AE%A2andornot.top.png" alt="博客andornot.top"></p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>面向过程（Procedure Oriented）是一种以过程为中心的编程思想，是一种自上而下、顺序执行的编程模式。</p>
<p>典型的面向过程语言：C语言。</p>
<p><strong>优点：</strong></p>
<p>流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。</p>
<p>效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。</p>
<p><strong>缺点：</strong></p>
<p>需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象（Object Oriented）是把现实中事物的属性和行为封装成对象，然后基于这些对象及对象的能力来实现业务逻辑。</p>
<p>目前比较流行的面向对象语言：Java、C#、C++、Python、Ruby、PHP等。</p>
<p><strong>优点:</strong></p>
<p>结构清晰，程序是模块化和结构化，更加符合人类的思维方式；</p>
<p>易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；</p>
<p>易维护，系统低耦合的特点有利于减少程序的后期维护工作量。</p>
<p><strong>缺点：</strong></p>
<p>开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。</p>
<p>性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。</p>
<h4 id="面向对象的三大基本特征"><a href="#面向对象的三大基本特征" class="headerlink" title="面向对象的三大基本特征"></a>面向对象的三大基本特征</h4><p><strong>封装：</strong></p>
<p>封装就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的类或者对象隐藏信息。</p>
<p><strong>继承：</strong></p>
<p>继承是指子类可以拥有父类的所有属性和方法（但是父类中的私有属性和方法，子类是无法访问的），并子类可以对父类进行扩展，添加新的属性和方法。</p>
<p>子类在初始化之前，一定会先访问父类的构造方法，完成父类数据的初始化，每一个构造方法默认隐藏一句代码<code>super();</code>。</p>
<p>通过子类对象访问一个方法，先去子类中找，子类没有再去父类中找。</p>
<p><strong>多态：</strong></p>
<p>多态就是指一个类实例的相同方法在不同情形下有不同的表现形式。</p>
<p>多态机制使具有不同内部结构的对象可以共享相同的外部接口。</p>
<p>Java中最常见的多态就是将子类传入父类参数中，当运行时调用父类方法时，通过传入的子类决定具体的内部结构或行为。</p>
<p>为了实现运行期的多态，需要满足三个条件：</p>
<ul>
<li>有类继承或者接口实现。</li>
<li>子类要重写父类的方法。</li>
<li>父类的引用指向子类的对象。</li>
</ul>
<h5 id="多态的好处和弊端"><a href="#多态的好处和弊端" class="headerlink" title="多态的好处和弊端"></a>多态的好处和弊端</h5><ul>
<li>好处：提高了程序的扩展性，具体表现为定义方法的时候，使用父类型作为参数，该方法就可以接收这父类的任意子类对象。</li>
<li>弊端：不能使用子类的特有功能</li>
</ul>
<h5 id="多态中的转型"><a href="#多态中的转型" class="headerlink" title="多态中的转型"></a>多态中的转型</h5><ul>
<li>向上转型：从子到父，父类引用指向子类对象</li>
<li>向下转型：从父到子，父类引用转为子类对象</li>
</ul>
<h5 id="instanceof-的用法"><a href="#instanceof-的用法" class="headerlink" title="instanceof 的用法"></a>instanceof 的用法</h5><p>instanceof概念在多态中引出，因为在多态发生时，子类只能调用父类中的方法（编译时类型的方法），而子类自己独有的方法（运行时类型的方法）无法调用，如果强制调用的话就需要<strong>向下转型</strong>，语法和基本类型的强制类型转换一样；但是向下转型具有一定的<strong>风险</strong>，很有可能无法成功转化，为了判断能否成功转化，就需要 instanceof 先进行一个判断，然后再进行转换操作。</p>
<p>语法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用类型变量(object) <span class="keyword">instanceof</span> 类(class)</span><br></pre></td></tr></table></figure>

<p>功能：<br><strong>判断前面的对象是否属于后面的类，或者属于其子类；</strong><br>如果是，返回 <strong>true</strong>，不是返回 <strong>false</strong>；</p>
<p>注意事项：<br>使用 instanceof 时需要保证：<br><strong>instanceof 前面的引用变量编译时的类型要么与后面的类型相同，要么与后面的类型具有父子继承关系</strong></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>抽象方法</strong>：将共性的行为（方法）抽取到父类之后，发现该方法的实现逻辑无法在父类中给出具体明确，该方法就可以定义为抽象方法。</p>
<p><strong>抽象类</strong>：如果一个类中存在抽象方法，那么该类就必须声明为抽象类。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>当一个类中的所有方法都是抽象方法的时候，我们就可以将其定义为接口，接口存在的意义主要是<strong>规则的定义</strong>和程序的扩展性。</p>
<p><strong>JDK8中接口成员的特点：</strong></p>
<ul>
<li><p>允许在接口中定义非抽象方法，但是需要使用关键字default修饰，这些方法就是默认方法。作用是解决接口升级的问题。</p>
<p>接口中默认方法的定义格式：public default  返回值类型 方法名(参数列表){  }</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字。</li>
<li>public可以省略，default不能省略。</li>
<li>如果实现了多个接口，多个接口中存在相同的方法声明，子类就必须对该方法重写。</li>
</ul>
</li>
<li><p>接口中允许定义static静态方法。</p>
<p>接口中静态方法的定义格式：public static 返回值类型 方法名(参数列表){  }</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用。</li>
<li>public可以省略，static不能省略。</li>
</ul>
</li>
</ul>
<p><strong>JDK9中接口成员的特点：</strong></p>
<ul>
<li>接口中可以定义私有方法。</li>
</ul>
<h4 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h4><ul>
<li><p>类和类的关系 </p>
<p>继承关系，只能单继承，但是可以多层继承</p>
</li>
<li><p>类和接口的关系</p>
<p>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口（如果直接父类和接口中出现了相同的方法声明，但是代码逻辑不一样，优先使用直接父类的代码逻辑）</p>
</li>
<li><p>接口和接口的关系</p>
<p>继承关系，可以单继承，也可以多继承</p>
</li>
</ul>
<h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong> ：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong> ：</p>
<ul>
<li><p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p>
</li>
<li><p>一个类只能继承一个类，但是可以实现多个接口。</p>
</li>
<li><p>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</p>
</li>
</ul>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类中</th>
<th>同一个包中子类、无关类</th>
<th>不同包的子类</th>
<th>不同包的无关类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h3 id="方法重载和重写"><a href="#方法重载和重写" class="headerlink" title="方法重载和重写"></a>方法重载和重写</h3><p><strong>重载：</strong></p>
<p>在同一个类中，多个方法有同样的名称，但是参数列表不同（参数类型不同、参数数量不同）。</p>
<p>被重载的方法可以改变返回值类型和访问修饰符，也可以声明新的或更广的检查异常。</p>
<p><strong>重写：</strong></p>
<p>在Java的子类与父类中，有两个名称和参数列表都相同的方法，由于它们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p>
<p>参数列表、返回值类型必须完全相同，重写方法的访问级别的限制性一定不能比被重写方法的限制性强，重写方法不能抛出新的或者更广的检查异常。</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>Java.lang.Object类中的clone方法可以用于复制一个新的对象。</p>
<p><strong>浅拷贝（Shadow Clone）：</strong></p>
<p>对基本数据类型进行值传递，对引用数据类型进行引用传递。</p>
<p>其实不重写clone方法的情况下就是浅拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p><strong>深拷贝（Deep Clone）：</strong></p>
<p>对基本数据类型进行值传递，对引用数据类型创建一个新的对象，并复制其内容。</p>
<p>深拷贝需要连带着要把要拷贝的对象内部的对象一起复制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>



<h3 id="8种基本数据类型"><a href="#8种基本数据类型" class="headerlink" title="8种基本数据类型"></a>8种基本数据类型</h3><p><img src="https://andornotblog.oss-cn-beijing.aliyuncs.com/imgs/summary1.png" alt="基本数据类型"></p>
<h4 id="使用基本数据类型的好处"><a href="#使用基本数据类型的好处" class="headerlink" title="使用基本数据类型的好处"></a>使用基本数据类型的好处</h4><p>在Java中，新创建的对象都是储存在堆里的（不考虑JIT优化的情况下），通过栈中的引用来使用这些对象。所以对象本身是比较消耗资源的。</p>
<p>对于经常用的类型，如int等，如果每次使用这种变量时都新建一个对象，就会比较笨重。所以Java提供了基本数据类型，不需要使用new创建，直接在栈内存中存储，因此会更加高效。</p>
<h4 id="整型的取值范围"><a href="#整型的取值范围" class="headerlink" title="整型的取值范围"></a>整型的取值范围</h4><p>Java中的整型属于有符号数。</p>
<p>8bit可以表示的数字：</p>
<ul>
<li>最大值：10000000（-128）</li>
<li>最小值：01111111（127）</li>
</ul>
<blockquote>
<p>1字节&#x3D;8位（bit）。</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>-128（$-2^7$）— 127（$2^7-1$）</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32768（$-2^{15}$）— 32767（$2^{15}-1$）</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648（$-2^{31}$）— 2147483647（$2^{31}-1$）</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>-922372036854775805（$-2^{63}$）— 9223372036854775807（$2^{63}-1$）</td>
<td>0L或0l</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>float：单精度，4字节，32位。</li>
<li>double：双精度，8字节，64位。</li>
<li>boolean：被编译成 int 类型来使用，占 4 个 byte 。❓</li>
<li>char：2字节，Java编译器默认使用Unicode编码。❓</li>
</ul>
</blockquote>
<h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><ul>
<li>自动装箱：将基本数据类型自动转换成对应的包装类。通过包装类的valueof()方法实现。</li>
<li>自动拆箱：将包装类自动转换成对应的基本数据类型。通过包装类对象的xxxValue()方法实现。</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<h4 id="整型的缓存机制"><a href="#整型的缓存机制" class="headerlink" title="整型的缓存机制"></a>整型的缓存机制</h4><p>在Java5中，在Integer的操作上引入了一个新功能来节省内存和提高性能——整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<ul>
<li><p>适用于-128至127区间的整数值。</p>
</li>
<li><p>只适用于自动装箱。使用构造函数创建的对象不适用。</p>
</li>
</ul>
<p>在Java6中，可以通过java.lang.Integer.IntegerCache.high设置最大值。</p>
<p><strong>其他缓存对象：</strong></p>
<ul>
<li>ByteCache用于缓存Byte对象。</li>
<li>ShortCache用于缓存Short对象。</li>
<li>LongCache用于缓存Long对象。</li>
<li>CharacterCache用于缓存Character对象。</li>
</ul>
<p>Byte、Short、Long对象都有固定的数值范围：-128至127。Character对象的数值范围是0至127。</p>
<p>除了Integer对象，数值范围都不能改变。</p>
<h4 id="基本类型和包装类怎么选"><a href="#基本类型和包装类怎么选" class="headerlink" title="基本类型和包装类怎么选"></a>基本类型和包装类怎么选</h4><ul>
<li>所以的POJO类属性必须使用包装数据类型。</li>
<li>RPC方法的返回值和参数必须使用包装数据类型。</li>
<li>所有的局部变量使用基本数据类型。</li>
</ul>
<p>包装类的默认值都是null，而基本数据类型的默认值是一个固定值，比如boolean是false，int是0等。</p>
<p>如果返回值使用基本数据类型，出现异常，则可能返回的是一个默认值。系统异常可能无法感知。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><a href="/2020/10/20/blogs/Java_1/">String字符串 | 与或非’s Blog (andornot.top)</a></p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final可以修饰方法、变量、类，final修饰的特点：</p>
<ul>
<li>修饰方法：表明该方法是最终方法，不能被重写；</li>
<li>修饰变量：表明该变量是常量，不能再次被赋值；</li>
<li>修饰类：表明该类是最终类，不能被继承。</li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java在java.util包中提供了两种基本的集合类：Collection和Map。</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="https://andornotblog.oss-cn-beijing.aliyuncs.com/imgs/summary2.png" alt="image-20220827134622549"></p>
<ul>
<li>List：元素有序且可重复。有序就是指元素的存储顺序和放入顺序是保持一致的；可重复是指在一个List中，同一个元素可以存储多份。</li>
<li>Set：元素无序且不可重复。</li>
<li>Queue：队列中的所有元素都在队列的尾部插入，并从头部移除。</li>
</ul>
<h4 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h4><ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li>
</ul>
<h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><p><a href="/2021/05/26/blogs/Java_28/">ArrayList和LinkedList的区别 | 与或非’s Blog (andornot.top)</a></p>
<h4 id="ArrayList源码-amp-扩容机制分析"><a href="#ArrayList源码-amp-扩容机制分析" class="headerlink" title="ArrayList源码&amp;扩容机制分析"></a>ArrayList源码&amp;扩容机制分析</h4><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/arraylist-source-code.html">ArrayList源码&amp;扩容机制分析 | JavaGuide</a></p>
<h4 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="https://andornotblog.oss-cn-beijing.aliyuncs.com/imgs/summary3.png" alt="image-20220827163802715"></p>
<h4 id="HashMap循环遍历"><a href="#HashMap循环遍历" class="headerlink" title="HashMap循环遍历"></a>HashMap循环遍历</h4><p><a href="/2020/11/18/blogs/Java_10_HashMap%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86/">HashMap循环遍历 | 与或非’s Blog </a></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><h3 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h3><h3 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h3><h3 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h3><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><h3 id="散列表（Hash）"><a href="#散列表（Hash）" class="headerlink" title="散列表（Hash）"></a>散列表（Hash）</h3><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><a href="https://andornot.top/2021/09/19/blogs/algorithm_1/">顺序查找和折半查找 | 与或非’s Blog (andornot.top)</a></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
<p>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><p>把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法让使用模板的类（继承抽象类的类）去重写抽象方法实现需求。</p>
<p>模板设计模式的优势：模板已经定义了通用结构，使用者只需关心自己需要实现的功能即可。</p>
<p>举个栗子🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作文模板类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CompositionTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;《我的爸爸》&quot;</span>);</span><br><span class="line"></span><br><span class="line">        body();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;啊！这就是我的爸爸！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">body</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tom</span> <span class="keyword">extends</span> <span class="title class_">CompositionTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">body</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;那是一个秋天，风儿那么缠绵，记忆中，那天爸爸骑车接我放学回家，&quot;</span> +</span><br><span class="line">                <span class="string">&quot;我的脚卡在了自行车链当中，爸爸蹬不动，他就站起来蹬...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Tom</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tom</span>();</span><br><span class="line">        tom.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">《我的爸爸》</span><br><span class="line">那是一个秋天，风儿那么缠绵，记忆中，那天爸爸骑车接我放学回家，我的脚卡在了自行车链当中，爸爸蹬不动，他就站起来蹬...</span><br><span class="line">啊！这就是我的爸爸！</span><br></pre></td></tr></table></figure>



<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h1 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h2><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/java/fbce2fffed52.html" rel="next" title="JVM基础">
      JVM基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">面向过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.2.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">面向对象的三大基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">多态的好处和弊端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">多态中的转型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#instanceof-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">1.1.2.1.3.</span> <span class="nav-text">instanceof 的用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.1.3.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.4.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">类和接口的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">接口和抽象类有什么共同点和区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.1.6.</span> <span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">1.1.7.</span> <span class="nav-text">方法重载和重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.1.8.</span> <span class="nav-text">浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.9.</span> <span class="nav-text">8种基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">使用基本数据类型的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">整型的取值范围</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="nav-number">1.1.10.</span> <span class="nav-text">自动拆装箱</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">整型的缓存机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E6%80%8E%E4%B9%88%E9%80%89"><span class="nav-number">1.1.10.2.</span> <span class="nav-text">基本类型和包装类怎么选</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.11.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.1.12.</span> <span class="nav-text">final关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6"><span class="nav-number">1.2.</span> <span class="nav-text">进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8API"><span class="nav-number">1.2.1.</span> <span class="nav-text">常用API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.3.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection"><span class="nav-number">1.3.1.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">ArrayList 和 Vector 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">ArrayList和LinkedList的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E6%BA%90%E7%A0%81-amp-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">ArrayList源码&amp;扩容机制分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">1.3.2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">HashMap循环遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">1.4.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.5.</span> <span class="nav-text">JVM</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">计算机基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">数组（Array）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="nav-number">2.1.2.</span> <span class="nav-text">栈（Stack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="nav-number">2.1.3.</span> <span class="nav-text">队列（Queue）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%88Linked-List%EF%BC%89"><span class="nav-number">2.1.4.</span> <span class="nav-text">链表（Linked List）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%EF%BC%88Tree%EF%BC%89"><span class="nav-number">2.1.5.</span> <span class="nav-text">树（Tree）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%EF%BC%88Graph%EF%BC%89"><span class="nav-number">2.1.6.</span> <span class="nav-text">图（Graph）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="nav-number">2.1.7.</span> <span class="nav-text">堆（Heap）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88Hash%EF%BC%89"><span class="nav-number">2.1.8.</span> <span class="nav-text">散列表（Hash）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">2.1.9.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.10.</span> <span class="nav-text">排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.2.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">2.3.</span> <span class="nav-text">网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">模板设计模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">3.1.</span> <span class="nav-text">MySQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">3.2.</span> <span class="nav-text">Redis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="nav-number">4.</span> <span class="nav-text">常用框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet"><span class="nav-number">4.1.</span> <span class="nav-text">Servlet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis"><span class="nav-number">4.2.</span> <span class="nav-text">MyBatis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">4.3.</span> <span class="nav-text">Spring</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">5.1.</span> <span class="nav-text">架构设计原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">分布式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="nav-number">6.</span> <span class="nav-text">常用工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">7.</span> <span class="nav-text">拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="nav-number">7.1.</span> <span class="nav-text">大数据</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">与或非</p>
  <div class="site-description" itemprop="description">个人成长记录与分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">与或非</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">334k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:56</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
