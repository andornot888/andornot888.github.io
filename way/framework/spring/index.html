<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_non1200.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_non1200.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_non1200.png">
  <link rel="mask-icon" href="/images/logo_and.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"andornot.top","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础Spring是什么？一句话概括：Spring 是一个轻量级、非入侵式的控制反转 (IOC) 和面向切面(AOP) 的框架。 2002年，一位知名的软件工程师和企业家Rod Johnson（罗德·约翰逊）首次发布了轻量级的Java开发框架Spring，随后渐渐崛起，并淘汰了 EJB 这个传统的重装骑兵。  到了现在，企业级开发的标配基本就是 Spring5 + Spring Boot 2 + J">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring">
<meta property="og:url" content="https://andornot.top/way/framework/spring/index.html">
<meta property="og:site_name" content="与或非&#39;s Blog">
<meta property="og:description" content="基础Spring是什么？一句话概括：Spring 是一个轻量级、非入侵式的控制反转 (IOC) 和面向切面(AOP) 的框架。 2002年，一位知名的软件工程师和企业家Rod Johnson（罗德·约翰逊）首次发布了轻量级的Java开发框架Spring，随后渐渐崛起，并淘汰了 EJB 这个传统的重装骑兵。  到了现在，企业级开发的标配基本就是 Spring5 + Spring Boot 2 + J">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242237603.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242242176.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242245391.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242312545.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242313147.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242314566.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251053099.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251122032.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251211711.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251214333.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251216988.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251219781.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251222415.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251228002.png">
<meta property="og:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251237060.png">
<meta property="article:published_time" content="2023-04-13T09:06:04.000Z">
<meta property="article:modified_time" content="2023-05-28T15:12:44.984Z">
<meta property="article:author" content="与或非">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242237603.png">


<link rel="canonical" href="https://andornot.top/way/framework/spring/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://andornot.top/way/framework/spring/index.html","path":"way/framework/spring/index.html","title":"Spring"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring | 与或非's Blog
</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">与或非's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-面试宝典"><a href="/way/" rel="section"><i class="fa fa-flag fa-fw"></i>面试宝典</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">Spring是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%88%E4%BC%98%E7%82%B9%EF%BC%89%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">Spring有哪些特性（优点）呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97%E5%91%A2%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">Spring有哪些模块呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%91%A2%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">Spring有哪些常用注解呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%B8%AD%E5%BA%94%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%91%A2%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">Spring 中应用了哪些设计模式呢？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC"><span class="nav-number">2.</span> <span class="nav-text">IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFIOC%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFDI"><span class="nav-number">2.1.</span> <span class="nav-text">说一说什么是IOC？什么是DI?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8BSpring-IOC%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%90%97"><span class="nav-number">2.2.</span> <span class="nav-text">能简单说一下Spring IOC的实现机制吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4BeanFactory%E5%92%8CApplicantContext"><span class="nav-number">2.3.</span> <span class="nav-text">说说BeanFactory和ApplicantContext?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E4%BC%9A%E5%B9%B2%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">你知道Spring容器启动阶段会干什么吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8BSpring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">能说一下Spring Bean生命周期吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BE%9D%E8%B5%96%E5%AE%9A%E4%B9%89%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">Bean定义和依赖定义有哪些方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">2.7.</span> <span class="nav-text">有哪些依赖注入的方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.8.</span> <span class="nav-text">Spring有哪些自动装配的方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%B8%AD%E7%9A%84-Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.9.</span> <span class="nav-text">Spring 中的 Bean 的作用域有哪些**?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-Bean-%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="nav-number">2.10.</span> <span class="nav-text">Spring 中的单例 Bean 会存在线程安全问题吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-number">2.11.</span> <span class="nav-text">什么是循环依赖？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%A3Spring%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">2.12.</span> <span class="nav-text">那Spring怎么解决循环依赖的呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Autowired%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">2.13.</span> <span class="nav-text">@Autowired的实现原理？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOP"><span class="nav-number">3.</span> <span class="nav-text">AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">说说什么是AOP？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">AOP有哪些核心概念？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">AOP有哪些环绕方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%B9%B3%E6%97%B6%E6%9C%89%E7%94%A8%E5%88%B0AOP%E5%90%97%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">说说你平时有用到AOP吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E4%BB%A3%E7%90%86-%EF%BC%9F"><span class="nav-number">3.5.</span> <span class="nav-text">说说JDK 动态代理和 CGLIB 代理 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4Spring-AOP-%E5%92%8C-AspectJ-AOP-%E5%8C%BA%E5%88%AB"><span class="nav-number">3.6.</span> <span class="nav-text">说说Spring AOP 和 AspectJ AOP 区别**?**</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">Spring 事务的种类？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">Spring 的事务隔离级别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">Spring 的事务传播机制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">4.4.</span> <span class="nav-text">声明式事务实现原理了解吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">4.5.</span> <span class="nav-text">声明式事务在哪些情况下会失效？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVC"><span class="nav-number">5.</span> <span class="nav-text">MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-MVC-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">Spring MVC 的核心组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-MVC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">Spring MVC 的工作流程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC-Restful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">SpringMVC Restful风格的接口的流程是什么样的呢？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot"><span class="nav-number">6.</span> <span class="nav-text">Spring Boot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSpringBoot%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">介绍一下SpringBoot，有哪些优点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">6.2.</span> <span class="nav-text">SpringBoot自动配置原理了解吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AASpringBoot-Srarter"><span class="nav-number">6.3.</span> <span class="nav-text">如何自定义一个SpringBoot Srarter?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Springboot-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">6.4.</span> <span class="nav-text">Springboot 启动原理？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="与或非"
      src="/images/logo_head300.png">
  <p class="site-author-name" itemprop="name">与或非</p>
  <div class="site-description" itemprop="description">个人成长记录与分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/andornottop" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;andornottop" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:andornottop@163.com" title="E-Mail → mailto:andornottop@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner page posts-expand">
    <ul class="sub-menu menu">
      
  <li class="menu-item menu-item-计算机基础"><a href="/way/base/" rel="section"><i class="fa fa-code fa-fw"></i>计算机基础</a></li>


      
  <li class="menu-item menu-item-java"><a href="/way/java/" rel="section"><i class="fa fa-mug-hot fa-fw"></i>Java</a></li>


      
  <li class="menu-item menu-item-开发框架"><a href="/way/framework/" rel="section"><i class="fa fa-cube fa-fw"></i>开发框架</a></li>


      
  <li class="menu-item menu-item-数据存储"><a href="/way/database/" rel="section"><i class="fa fa-database fa-fw"></i>数据存储</a></li>


      
  <li class="menu-item menu-item-消息队列"><a href="/way/mq/" rel="section"><i class="fa fa-random fa-fw"></i>消息队列</a></li>


      
  <li class="menu-item menu-item-devops"><a href="/way/devops/" rel="section"><i class="fa fa-code-branch fa-fw"></i>DevOps</a></li>


    </ul>
    <ul class="sub-menu menu">
      
  <li class="menu-item menu-item-servlet"><a href="/way/framework/servlet/" rel="section"><i class="fa fa-server fa-fw"></i>Servlet</a></li>


      
  <li class="menu-item menu-item-mybatis"><a href="/way/framework/mybatis/" rel="section"><i class="fa fa-dove fa-fw"></i>MyBatis</a></li>


      
  <li class="menu-item menu-item-spring"><a href="/way/framework/spring/" rel="section"><i class="fa fa-leaf fa-fw"></i>Spring</a></li>


      
  <li class="menu-item menu-item-spring-cloud"><a href="/way/framework/springcloud/" rel="section"><i class="fa fa-cloud fa-fw"></i>Spring Cloud</a></li>


    </ul>


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header">

<h1 class="post-title" itemprop="name headline">Spring
</h1>

<div class="post-meta-container">
  <ul class="breadcrumb">
            <li><a href="/way/">面试宝典</a></li>
            <li><a href="/way/framework/">开发框架</a></li>
          <li>SPRING</li>
  </ul>
</div>

</header>

      
      
      <div class="post-body">
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Spring是什么？"><a href="#Spring是什么？" class="headerlink" title="Spring是什么？"></a>Spring是什么？</h2><p>一句话概括：<strong>Spring 是一个轻量级、非入侵式的控制反转 (IOC) 和面向切面(AOP) 的框架。</strong></p>
<p>2002年，一位知名的软件工程师和企业家Rod Johnson（罗德·约翰逊）首次发布了轻量级的Java开发框架Spring，随后渐渐崛起，并淘汰了 EJB 这个传统的重装骑兵。</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242237603.png"></p>
<p>到了现在，企业级开发的标配基本就是 <strong>Spring5 + Spring Boot 2 + JDK 8</strong></p>
<h2 id="Spring有哪些特性（优点）呢？"><a href="#Spring有哪些特性（优点）呢？" class="headerlink" title="Spring有哪些特性（优点）呢？"></a>Spring有哪些特性（优点）呢？</h2><p><strong>1. IOC 和 DI 的支持</strong></p>
<p>Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring工厂用于生成 Bean，并且管理 Bean 的生命周期，实现高内聚低耦合的设计理念。</p>
<p><strong>2. AOP 编程的支持</strong></p>
<p>Spring 提供了面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p>
<p><strong>3. 声明式事务的支持</strong></p>
<p>支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的JDBC代码，都可以不用自己写了。</p>
<p><strong>4. 快捷测试的支持</strong></p>
<p>Spring 对 Junit 提供支持，可以通过注解快捷地测试 Spring 程序。</p>
<p><strong>5. 快速集成功能</strong></p>
<p>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p>
<p><strong>6. 复杂API模板封装</strong></p>
<p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p>
<h2 id="Spring有哪些模块呢？"><a href="#Spring有哪些模块呢？" class="headerlink" title="Spring有哪些模块呢？"></a>Spring有哪些模块呢？</h2><p>Spring 框架是分模块存在，除了最核心的 Spring Core Container 是必要模块之外，其他模块都是 可选 ，大约有 20 多个模块。</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242242176.png"></p>
<p>最主要的七大模块：</p>
<p><strong>1. Spring Core ：</strong></p>
<p>Spring 核心，它是框架最基础的部分，提供 IOC 和依赖注入 DI 特性。</p>
<p><strong>2. Spring Context ：</strong></p>
<p>Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</p>
<p><strong>3. Spring Web ：</strong></p>
<p>它提供 Web 应用开发的支持。</p>
<p><strong>4. Spring MVC ：</strong></p>
<p>它针对 Web 应用中 MVC 思想的实现。</p>
<p><strong>5. Spring DAO ：</strong></p>
<p>提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</p>
<p><strong>6. Spring ORM ：</strong></p>
<p>它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。</p>
<p><strong>7. Spring AOP ：</strong></p>
<p>即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</p>
<h2 id="Spring有哪些常用注解呢？"><a href="#Spring有哪些常用注解呢？" class="headerlink" title="Spring有哪些常用注解呢？"></a>Spring有哪些常用注解呢？</h2><p>Spring有很多模块，甚至广义的SpringBoot、SpringCloud也算是Spring的一部分，我们来分模块，按功能来看一下一些常用的注解：</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242245391.png"></p>
<p><strong>Web:</strong></p>
<ul>
<li><p>@Controller：组合注解（组合了@Component注解），应用在MVC层（控制层）。</p>
</li>
<li><p>@RestController：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p>
</li>
<li><p>@RequestMapping：用于映射Web请求，包括访问路径和参数。如果是Restful风格接口，还可以根据请求类型使用不同的注解：</p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
</ul>
</li>
<li><p>@ResponseBody：支持将返回值放在response内，而不是一个页面，通常用户返回json数据。</p>
</li>
<li><p>@RequestBody：允许request的参数在request体中，而不是在直接连接在地址后面。</p>
</li>
<li><p>@PathVariable：用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p>
</li>
</ul>
<p><strong>容器:</strong></p>
<ul>
<li><p>@Component：表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。</p>
</li>
<li><p>@Service：组合注解（组合了@Component注解），应用在service层（业务逻辑层）。</p>
</li>
<li><p>@Repository：组合注解（组合了@Component注解），应用在dao层（数据访问层）。</p>
</li>
<li><p>@Autowired：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</p>
</li>
<li><p>@Qualifier：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解。</p>
</li>
<li><p>@Configuration：声明当前类是一个配置类（相当于一个Spring配置的xml文件）。</p>
</li>
<li><p>@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</p>
</li>
<li><p>@Bean：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod&#x3D;”init”,destroyMethod&#x3D;”destroy”)定义，在构造之后执行init，在销毁之前执行destroy。</p>
</li>
<li><p>@Scope：定义我们采用什么模式去创建Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</p>
</li>
</ul>
<p><strong>AOP:</strong></p>
<ul>
<li><p>@Aspect：声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p>
</li>
<li><p>@After ：在方法执行之后执行（方法上）。</p>
</li>
<li><p>@Before ： 在方法执行之前执行（方法上）。</p>
</li>
<li><p>@Around ： 在方法执行之前与之后执行（方法上）。</p>
</li>
<li><p>@PointCut ： 声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。</p>
</li>
</ul>
<p><strong>事务：</strong></p>
<ul>
<li>@Transactional：在要开启事务的方法上使用@Transactional注解，即可声明式开启事务。</li>
</ul>
<h2 id="Spring-中应用了哪些设计模式呢？"><a href="#Spring-中应用了哪些设计模式呢？" class="headerlink" title="Spring 中应用了哪些设计模式呢？"></a>Spring 中应用了哪些设计模式呢？</h2><p><strong>1. 工厂模式 :</strong> </p>
<p>Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</p>
<p><strong>2. 代理模式 :</strong> </p>
<p>Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</p>
<p><strong>3. 单例模式 :</strong> </p>
<p>Spring 中的 Bean 默认都是单例的，这样有利于容器对Bean的管理。</p>
<p><strong>4. 模板模式 :</strong> </p>
<p>Spring 中 JdbcTemplate、RestTemplate 等以 Template结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。</p>
<p><strong>5. 观察者模式 :</strong> </p>
<p>Spring 事件驱动模型就是观察者模式很经典的一个应用。</p>
<p><strong>6. 适配器模式 :</strong></p>
<p>Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、SpringMVC 中也是用到了适配器模式适配 Controller。</p>
<p><strong>7. 策略模式 ：</strong></p>
<p>Spring中有一个Resource接口，它的不同实现类，会根据不同的策略去访问资源。</p>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="说一说什么是IOC？什么是DI"><a href="#说一说什么是IOC？什么是DI" class="headerlink" title="说一说什么是IOC？什么是DI?"></a>说一说什么是IOC？什么是DI?</h2><p>Java 是面向对象的编程语言，一个个实例对象相互合作组成了业务逻辑，原来，我们都是在代码里创建对象和对象的依赖。</p>
<p><strong>IOC</strong>（控制反转）：就是由容器来负责控制对象的生命周期和对象间的关系。以前是我们想要什么，就自己创建什么，现在是我们需要什么，容器就给我们送来什么。</p>
<p><strong>DI</strong>（依赖注入）：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法IOC和DI是一回事，有的说法是IOC是思想，DI是IOC的实现。</p>
<p>使用<strong>IOC</strong>主要是为了解耦，硬编码会造成对象间的过度耦合，使用IOC之后，我们可以不用关心对象间的依赖，专心开发应用就行。</p>
<h2 id="能简单说一下Spring-IOC的实现机制吗"><a href="#能简单说一下Spring-IOC的实现机制吗" class="headerlink" title="能简单说一下Spring IOC的实现机制吗"></a>能简单说一下Spring IOC的实现机制吗</h2><ol>
<li>配置文件或注解：在Spring中，可以使用XML配置文件、Java注解或Java类依赖关系等方式来定义Bean及其依赖关系。</li>
<li>BeanDefinition解析：Spring容器将读取并解析配置文件或注解，然后根据定义创建BeanDefinition对象。BeanDefinition对象包含了Bean的名称、类型、作用范围和属性等信息。</li>
<li>BeanFactory实例化：当应用程序需要访问Bean时，Spring容器会实例化一个BeanFactory。BeanFactory是一个工厂模式，它负责创建、组装和管理Bean对象。</li>
<li>Bean实例化：当容器实例化BeanFactory后，它将根据BeanDefinition创建相应的Bean实例。默认情况下，Spring使用无参构造函数来实例化Bean，但你也可以通过工厂方法、构造函数参数或其他方式来自定义Bean的实例化。</li>
<li>依赖注入：一旦Bean实例化完成，容器会扫描Bean的属性，并将它们注入到所需的依赖项中。这个过程通常使用setter方法、构造函数参数或字段注入来完成。</li>
<li>生命周期管理：Spring容器负责Bean的生命周期管理，它使用各种回调接口（例如InitializingBean和DisposableBean）来处理Bean的初始化和销毁操作。</li>
</ol>
<h2 id="说说BeanFactory和ApplicantContext"><a href="#说说BeanFactory和ApplicantContext" class="headerlink" title="说说BeanFactory和ApplicantContext?"></a>说说BeanFactory和ApplicantContext?</h2><p>BeanFactory和ApplicationContext都是Spring框架中用于管理Bean对象的容器。</p>
<p>BeanFactory是一个基本的Bean容器，提供了最基本的依赖注入和生命周期管理功能。它的主要功能是加载、实例化、配置和管理Bean对象。当应用程序需要访问Bean时，BeanFactory会实例化一个Bean实例，并按需提供给应用程序。BeanFactory通常使用延迟加载策略，也就是说只有在访问Bean时才会实例化它。</p>
<p>ApplicationContext是BeanFactory的超集，提供了更多的企业级服务，如AOP、事务管理、国际化和事件处理等。ApplicationContext不仅支持BeanFactory的所有功能，而且还提供了更高级别的功能和特性，例如自动装配、注解驱动的Bean定义和更方便的资源管理。ApplicationContext通常使用预先加载策略，也就是说在启动时就会实例化所有Bean。</p>
<p>以下是BeanFactory和ApplicationContext的一些区别：</p>
<ol>
<li>功能差异：BeanFactory提供了基本的Bean管理和依赖注入功能，而ApplicationContext除了提供BeanFactory的所有功能以外，还提供了更高级别的功能和特性。</li>
<li>初始化方式：BeanFactory通常使用延迟加载策略，只有在实际使用时才会初始化Bean，而ApplicationContext则通常使用预先加载策略，在启动时就完成所有Bean的初始化。</li>
<li>性能差异：由于ApplicationContext需要在启动时初始化所有Bean，因此它比BeanFactory更加耗费内存和CPU资源。但是通过使用缓存和其他机制，Spring可以在一定程度上优化应用程序的性能。</li>
<li>适用范围：BeanFactory适用于基本的应用程序，而ApplicationContext更适用于大型企业级应用程序。</li>
</ol>
<h2 id="你知道Spring容器启动阶段会干什么吗？"><a href="#你知道Spring容器启动阶段会干什么吗？" class="headerlink" title="你知道Spring容器启动阶段会干什么吗？"></a>你知道Spring容器启动阶段会干什么吗？</h2><p>Spring的IOC容器工作的过程，其实可以划分为两个阶段：<strong>容器启动阶段和Bean实例化阶段</strong>。</p>
<p>其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的Bean定义中。</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242312545.png"></p>
<p>容器启动开始，首先会通过某种途径加载Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Congiguration MetaData进行解析和分析，并将分析后的信息组为相应的BeanDefinition。</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242313147.png"></p>
<p>最后把这些保存了Bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器启动就完成了。</p>
<h2 id="能说一下Spring-Bean生命周期吗？"><a href="#能说一下Spring-Bean生命周期吗？" class="headerlink" title="能说一下Spring Bean生命周期吗？"></a>能说一下Spring Bean生命周期吗？</h2><p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305242314566.png"></p>
<ol>
<li>实例化Bean对象：当Spring容器启动时，它会根据配置文件或注解来创建BeanDefinition对象，并使用反射机制实例化Bean对象。</li>
<li>设置Bean属性：一旦Bean对象被实例化，Spring容器会自动扫描Bean的属性，并将其设置为相应的依赖项，也就是所需要引用的其他Bean或常量值。</li>
<li>BeanPostProcessor的前置处理：在Bean对象完成依赖注入之后，Spring容器会调用注册的BeanPostProcessor实例来为Bean提供额外的处理逻辑。这些处理逻辑通常包括检查Bean对象是否合法、修改Bean属性值等。</li>
<li>初始化Bean：在Bean对象完成属性注入后，Spring容器会回调Bean的init方法（例如InitializingBean接口的afterPropertiesSet()方法），来执行Bean的自定义初始化逻辑。</li>
<li>BeanPostProcessor的后置处理：在Bean对象完成初始化后，Spring容器再次调用已注册的BeanPostProcessor实例来对Bean进行后置处理，例如添加代理、修改属性值等。</li>
<li>使用Bean：在Bean对象完成初始化之后，Spring容器会将其提供给应用程序使用。此时，Bean对象进入可用状态，应用程序可以使用其中的属性和方法。</li>
<li>销毁Bean：当Spring容器关闭或者Bean不再被使用时，它会调用Bean的destroy方法（例如DisposableBean接口的destroy()方法），来执行Bean的自定义销毁逻辑。</li>
</ol>
<h2 id="Bean定义和依赖定义有哪些方式？"><a href="#Bean定义和依赖定义有哪些方式？" class="headerlink" title="Bean定义和依赖定义有哪些方式？"></a>Bean定义和依赖定义有哪些方式？</h2><p>有三种方式：<strong>直接编码方式、配置文件方式、注解方式</strong>。</p>
<ul>
<li><p>直接编码方式：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。</p>
</li>
<li><p>配置文件方式：通过xml、propreties类型的配置文件，配置相应的依赖关系，Spring读取配置文件，完成依赖关系的注入。</p>
</li>
<li><p>注解方式：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring会扫描注解，完成依赖关系的注入。</p>
</li>
</ul>
<h2 id="有哪些依赖注入的方法？"><a href="#有哪些依赖注入的方法？" class="headerlink" title="有哪些依赖注入的方法？"></a>有哪些依赖注入的方法？</h2><ol>
<li><p>Setter注入：这是最常用的依赖注入方式。容器通过调用Bean的setter方法来设置所需的依赖项，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> MyDao myDao;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyDao</span><span class="params">(MyDao myDao)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.myDao = myDao;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数注入：这是另一种常用的依赖注入方式。容器通过调用Bean的构造函数来创建Bean，并传递所需的依赖项作为参数，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> MyDao myDao;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MyDao myDao)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.myDao = myDao;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字段注入：使用@Autowired或@Inject注解，在字段上标记需要注入的依赖项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> MyDao myDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口注入：将依赖项定义为接口类型，在运行时动态找到实现该接口的Bean并注入。</p>
</li>
<li><p>基于注解的注入：使用自定义注解来标记需要注入的依赖项，然后通过扫描等机制实现注入。</p>
</li>
</ol>
<h2 id="Spring有哪些自动装配的方式？"><a href="#Spring有哪些自动装配的方式？" class="headerlink" title="Spring有哪些自动装配的方式？"></a>Spring有哪些自动装配的方式？</h2><ol>
<li><strong>组件扫描（Component Scan）</strong>：通过在配置类上添加<code>@ComponentScan</code>注解，Spring会自动扫描指定包下的所有组件，并将其注册到容器中。可以使用其他注解如<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>等来进一步细化扫描范围。</li>
<li><strong>自动装配（Autowiring）</strong>：当一个Bean依赖另一个Bean时，Spring可以自动将所依赖的Bean注入到该Bean中。通过在依赖的属性上添加<code>@Autowired</code>注解来实现自动装配，或者在构造函数上添加<code>@Autowired</code>注解来实现构造函数自动装配。</li>
<li><strong>Java配置（Java Configuration）</strong>：通过在配置类中使用<code>@Bean</code>注解来定义Bean，Spring会自动将这些Bean注册到容器中。</li>
<li><strong>基于XML配置的自动装配</strong>：在XML配置文件中使用<code>&lt;context:component-scan&gt;</code>元素来开启组件扫描。使用<code>&lt;bean&gt;</code>元素来定义Bean，并使用<code>autowire=&quot;byType&quot;</code>或<code>autowire=&quot;byName&quot;</code>来实现自动装配。</li>
</ol>
<h2 id="Spring-中的-Bean-的作用域有哪些"><a href="#Spring-中的-Bean-的作用域有哪些" class="headerlink" title="Spring 中的 Bean 的作用域有哪些**?**"></a><strong>Spring</strong> 中的 <strong>Bean</strong> 的作用域有哪些**?**</h2><ul>
<li><p>singleton : 在Spring容器仅存在一个Bean实例，Bean以单实例的方式存在，是Bean默认的作用域。</p>
</li>
<li><p>prototype : 每次从容器重调用Bean时，都会返回一个新的实例。</p>
</li>
</ul>
<p>以下三个作用域于只在Web应用中适用：</p>
<ul>
<li><p>request : 每一次HTTP请求都会产生一个新的Bean，该Bean仅在当前HTTP Request内有效。</p>
</li>
<li><p>session : 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。</p>
</li>
<li><p>globalSession ：同一个全局Session共享一个Bean，只用于基于Protlet的Web应用，Spring5中已经不存在了。</p>
</li>
</ul>
<h2 id="Spring-中的单例-Bean-会存在线程安全问题吗？"><a href="#Spring-中的单例-Bean-会存在线程安全问题吗？" class="headerlink" title="Spring 中的单例 Bean 会存在线程安全问题吗？"></a><strong>Spring</strong> 中的单例 <strong>Bean</strong> 会存在线程安全问题吗？</h2><p>首先结论在这：<strong>Spring中的单例Bean不是线程安全的。</strong></p>
<p>因为单例Bean，是全局只有一个Bean，所有线程共享。如果说单例Bean，是一个无状态的，也就是线程中的操作不会对Bean中的成员变量执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p>
<p>假如这个Bean是有状态的，也就是会对Bean中的成员变量进行写操作，那么可能就存在线程安全的问题。单例Bean线程安全问题怎么解决呢？</p>
<p>常见的有这么些解决办法：</p>
<p><strong>1.</strong> 将Bean定义为多例</p>
<p>这样每一个线程请求过来都会创建一个新的Bean，但是这样容器就不好管理Bean，不能这么办。</p>
<p><strong>2.</strong> 在Bean对象中尽量避免定义可变的成员变量</p>
<p>削足适履了属于是，也不能这么干。</p>
<p><strong>3.</strong> 将Bean中的成员变量保存在ThreadLocal中⭐</p>
<p>我们知道ThredLoca能保证多线程下变量的隔离，可以在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal里，这是推荐的一种方式。</p>
<h2 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h2><p>循环依赖指的是两个或多个Bean相互依赖，形成了一个循环引用的关系。这种情况下，当Spring容器尝试去创建这些Bean时，会出现无法解决依赖关系的情况。</p>
<p>例如，Bean A依赖于Bean B，而Bean B又依赖于Bean A。在创建Bean A时，Spring发现它依赖于Bean B，因此开始创建Bean B。但是，在创建Bean B时，Spring发现它依赖于Bean A，而Bean A还未创建完成，因此无法注入实例，于是创建Bean B的过程也被中断了。这样就导致了一个死循环。</p>
<p>循环依赖可能会导致应用程序崩溃，因为它破坏了对象图中的树状结构，使得对象之间的关系变得混乱不清。为了避免循环依赖的问题，可以使用构造函数注入方式来代替属性注入方式，或者使用<code>@Lazy</code>注解延迟加载Bean，或者通过重构代码来消除循环依赖。</p>
<h2 id="那Spring怎么解决循环依赖的呢？"><a href="#那Spring怎么解决循环依赖的呢？" class="headerlink" title="那Spring怎么解决循环依赖的呢？"></a>那<strong>Spring</strong>怎么解决循环依赖的呢？</h2><p>Spring采用了“提前暴露”的方式来解决循环依赖的问题。具体来说，当Spring发现两个Bean之间存在循环依赖时，它会先创建实例对象，然后将对方的引用提前注入到实例中，再完成剩下的属性注入。</p>
<p>下面是一个简单的例子来说明Spring是如何处理循环依赖的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，类A和类B相互依赖。当Spring容器开始创建Bean时，它会先创建A的实例，但此时无法注入B，因为B还未创建完成。为了解决这个问题，Spring会先创建B的实例，然后注入A的引用到B中，最后才将B注入到A中。</p>
<p>需要注意的是，只有通过构造函数注入或者<code>@Autowired</code>注解的依赖可以解决循环依赖。如果使用setter方法注入依赖，则无法解决循环依赖问题。另外，在使用setter方法进行属性注入时，如果要避免循环依赖问题，可以使用<code>@Lazy</code>注解进行延迟初始化。</p>
<h2 id="Autowired的实现原理？"><a href="#Autowired的实现原理？" class="headerlink" title="@Autowired的实现原理？"></a><strong>@Autowired</strong>的实现原理？</h2><p><code>@Autowired</code>是Spring中用于进行自动装配的注解，它的实现原理主要涉及到以下两个方面：</p>
<ol>
<li>自动装配的处理过程</li>
</ol>
<p>当Spring容器初始化一个Bean时，会检查该Bean的依赖关系，并尝试为其注入依赖的Bean。如果发现了被<code>@Autowired</code>注解标记的属性或构造函数参数，则会根据这些依赖的类型来查找对应的Bean，并将其注入到目标对象中。</p>
<ol start="2">
<li>注入Bean的方式</li>
</ol>
<p>当Spring找到了需要注入的Bean时，会将其注入到目标对象中。具体注入的方式取决于所使用的注入器（如<code>AutowiredAnnotationBeanPostProcessor</code>），通常有以下几种方式：</p>
<ul>
<li>属性注入：将被注入的Bean直接赋值给目标对象中对应的属性。</li>
<li>构造函数注入：通过调用目标对象的构造函数来注入Bean。</li>
<li>方法注入：通过调用目标对象的setter方法来注入Bean。</li>
</ul>
<p>在进行自动装配时，Spring会优先按照类型查找Bean，如果存在多个匹配的Bean，则会按照名称进行匹配。可以使用<code>@Qualifier</code>注解指定要注入的Bean的名称。</p>
<p>需要注意的是，当通过<code>@Autowired</code>注入依赖时，如果找不到对应的Bean，则会抛出异常。可以通过将<code>required</code>属性设置为<code>false</code>来避免这种情况，此时如果找不到对应的Bean，该属性将为<code>null</code>。</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="说说什么是AOP？"><a href="#说说什么是AOP？" class="headerlink" title="说说什么是AOP？"></a>说说什么是<strong>AOP</strong>？</h2><p>AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p>
<p>我们可以把 <strong>日志记录</strong> 和 <strong>数据校验</strong> 可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。</p>
<p>业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。</p>
<p>AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。</p>
<p>AOP 的核心其实就是动态代理，如果是实现了接口的话就会使用 JDK 动态代理，否则使用 CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。</p>
<h2 id="AOP有哪些核心概念？"><a href="#AOP有哪些核心概念？" class="headerlink" title="AOP有哪些核心概念？"></a><strong>AOP</strong>有哪些核心概念？</h2><ul>
<li><p>切面（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</p>
</li>
<li><p>连接点（Joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
</li>
<li><p>切点（Pointcut）：对连接点进行拦截的定位</p>
</li>
<li><p>通知（Advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作增强</p>
</li>
<li><p>目标对象 （Target）：代理的目标对象</p>
</li>
<li><p>织入（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。</p>
<ul>
<li><p>编译期织入：切面在目标类编译时被织入</p>
</li>
<li><p>类加载期织入：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</p>
</li>
<li><p>运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</p>
<p>Spring采用运行期织入，而AspectJ采用编译期织入和类加载器织入。</p>
</li>
</ul>
</li>
<li><p>引介（introduction）：引介是一种特殊的增强，可以动态地为类添加一些属性和方法</p>
</li>
</ul>
<h2 id="AOP有哪些环绕方式？"><a href="#AOP有哪些环绕方式？" class="headerlink" title="AOP有哪些环绕方式？"></a><strong>AOP</strong>有哪些环绕方式？</h2><p>AOP 一般有 <strong>5</strong> 种环绕方式：</p>
<ul>
<li><p>前置通知 (@Before)</p>
</li>
<li><p>返回通知 (@AfterReturning)</p>
</li>
<li><p>异常通知 (@AfterThrowing)</p>
</li>
<li><p>后置通知 (@After)</p>
</li>
<li><p>环绕通知 (@Around)</p>
</li>
</ul>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251053099.png"></p>
<p>多个切面的情况下，可以通过 @Order 指定先后顺序，数字越小，优先级越高。</p>
<h2 id="说说你平时有用到AOP吗？"><a href="#说说你平时有用到AOP吗？" class="headerlink" title="说说你平时有用到AOP吗？"></a>说说你平时有用到<strong>AOP</strong>吗？</h2><p>这里给出一个小例子，SpringBoot项目中，利用AOP打印接口的入参和出参日志，以及执行时间，还是比较快捷的。</p>
<ul>
<li>引入依赖：引入AOP依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starteraop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义注解：自定义一个注解作为切点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置AOP切面：</p>
<ul>
<li>@Aspect：标识切面</li>
<li>@Pointcut：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定义注解是比较常用的一种。</li>
<li>@Before：在切点之前织入，打印了一些入参信息</li>
<li>@Around：环绕切点，打印返回参数和接口执行时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以自定义 <span class="doctag">@WebLog</span> 注解为切点</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)</span></span><br><span class="line"><span class="meta">&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在切点之前织入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span></span><br><span class="line">Throwable &#123;</span><br><span class="line"><span class="comment">// 开始打印请求日志</span></span><br><span class="line"><span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes)</span><br><span class="line">RequestContextHolder.getRequestAttributes();</span><br><span class="line"> <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line"><span class="comment">// 打印请求相关参数</span></span><br><span class="line">logger.info(<span class="string">&quot;==========================================</span></span><br><span class="line"><span class="string">Start ==========================================&quot;</span>);</span><br><span class="line"><span class="comment">// 打印请求 url</span></span><br><span class="line">logger.info(<span class="string">&quot;URL : &#123;&#125;&quot;</span>,</span><br><span class="line">request.getRequestURL().toString());</span><br><span class="line"><span class="comment">// 打印 Http method</span></span><br><span class="line">logger.info(<span class="string">&quot;HTTP Method : &#123;&#125;&quot;</span>,</span><br><span class="line">request.getMethod());</span><br><span class="line"><span class="comment">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class="line">logger.info(<span class="string">&quot;Class Method : &#123;&#125;.&#123;&#125;&quot;</span>,</span><br><span class="line">joinPoint.getSignature().getDeclaringTypeName(),</span><br><span class="line">joinPoint.getSignature().getName());</span><br><span class="line"><span class="comment">// 打印请求的 IP</span></span><br><span class="line">logger.info(<span class="string">&quot;IP : &#123;&#125;&quot;</span>,request.getRemoteAddr());</span><br><span class="line"><span class="comment">// 打印请求入参</span></span><br><span class="line">logger.info(<span class="string">&quot;Request Args : &#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(joinPoint.getArgs()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在切点之后织入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After(&quot;webLog()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// 结束后打个分隔线，方便查看</span></span><br><span class="line">logger.info(<span class="string">&quot;===========================================</span></span><br><span class="line"><span class="string">End ===========================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 环绕</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint</span></span><br><span class="line"><span class="params">proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line"><span class="comment">// 打印出参</span></span><br><span class="line">logger.info(<span class="string">&quot;Response Args : &#123;&#125;&quot;</span>, <span class="keyword">new</span></span><br><span class="line"><span class="title class_">ObjectMapper</span>().writeValueAsString(result));</span><br><span class="line"><span class="comment">// 执行耗时</span></span><br><span class="line">logger.info(<span class="string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>,</span><br><span class="line">System.currentTimeMillis() - startTime);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：只需要在接口上加上自定义注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@WebLog(desc = &quot;这是一个欢迎接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="说说JDK-动态代理和-CGLIB-代理-？"><a href="#说说JDK-动态代理和-CGLIB-代理-？" class="headerlink" title="说说JDK 动态代理和 CGLIB 代理 ？"></a>说说<strong>JDK</strong> 动态代理和 <strong>CGLIB</strong> 代理 ？</h2><p>Spring的AOP是通过动态代理来实现的，动态代理主要有两种方式JDK动态代理和Cglib动态代理，这两种动态代理的使用和原理有些不同。</p>
<p><strong>JDK 动态代理</strong></p>
<p><strong>1.</strong> Interface ：对于 JDK 动态代理，目标类需要实现一个Interface。</p>
<p><strong>2.</strong> InvocationHandler ：InvocationHandler是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。</p>
<p><strong>3.</strong> Proxy ：Proxy利用InvocationHandler动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。</p>
<p><strong>CgLib</strong> 动态代理</p>
<p><strong>1.</strong> 使用JDK创建代理有一大限制，它只能为接口创建代理实例，而CgLib 动态代理就没有这个限制。</p>
<p><strong>2.</strong> CgLib 动态代理是使用字节码处理框架 ASM ，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</p>
<p><strong>3.</strong> CgLib 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</p>
<h2 id="说说Spring-AOP-和-AspectJ-AOP-区别"><a href="#说说Spring-AOP-和-AspectJ-AOP-区别" class="headerlink" title="说说Spring AOP 和 AspectJ AOP 区别**?**"></a>说说<strong>Spring AOP</strong> 和 <strong>AspectJ AOP</strong> 区别**?**</h2><p><strong>Spring AOP</strong></p>
<p>Spring AOP 属于 运行时增强 ，主要具有如下特点：</p>
<p><strong>1.</strong> 基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现</p>
<p><strong>2.</strong> Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯Java 代码实现</p>
<p><strong>3.</strong> 在性能上，由于 Spring AOP 是基于 动态代理 来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如AspectJ 的那么好。</p>
<p><strong>4.</strong> Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</p>
<p><strong>AspectJ</strong></p>
<p>AspectJ 是一个易用的功能强大的 AOP 框架，属于 编译时增强 ， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p>
<p>AspectJ 属于静态织入，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p>
<p><strong>1.</strong> 编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</p>
<p><strong>2.</strong> 编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</p>
<p><strong>3.</strong> 类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</p>
<p>整体对比如下：</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251122032.png"></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring</p>
<p>是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据</p>
<p>库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p>
<h2 id="Spring-事务的种类？"><a href="#Spring-事务的种类？" class="headerlink" title="Spring 事务的种类？"></a><strong>Spring</strong> 事务的种类？</h2><p>Spring 支持 <strong>编程式事务</strong> 管理和 <strong>声明式事务</strong>管理两种方式：</p>
<p><strong>编程式事务</strong></p>
<p>编程式事务管理使用 TransactionTemplate，需要显式执行事务。</p>
<p><strong>声明式事务</strong></p>
<p>声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<p>优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 @Transactional 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h2 id="Spring-的事务隔离级别？"><a href="#Spring-的事务隔离级别？" class="headerlink" title="Spring 的事务隔离级别？"></a><strong>Spring</strong> 的事务隔离级别？</h2><p>Spring的接口TransactionDefinition中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：</p>
<p><strong>1.</strong> ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。</p>
<p><strong>2.</strong> ISOLATION_READ_UNCOMMITTED：读未提交</p>
<p><strong>3.</strong> ISOLATION_READ_COMMITTED：读已提交</p>
<p><strong>4.</strong> ISOLATION_REPEATABLE_READ：可重复读</p>
<p><strong>5.</strong> ISOLATION_SERIALIZABLE：串行化</p>
<h2 id="Spring-的事务传播机制？"><a href="#Spring-的事务传播机制？" class="headerlink" title="Spring 的事务传播机制？"></a><strong>Spring</strong> 的事务传播机制？</h2><p>Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。</p>
<p>事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251211711.png"></p>
<p>Spring默认的事务传播行为是PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个ServiceX#methodX()都工作在事务环境下（均被Spring事务增强），且程序中存在调用链Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这3个服务类的三个方法通过Spring的事务传播机制都工作在同一个事务中。</p>
<h2 id="声明式事务实现原理了解吗？"><a href="#声明式事务实现原理了解吗？" class="headerlink" title="声明式事务实现原理了解吗？"></a>声明式事务实现原理了解吗？</h2><p>就是通过AOP&#x2F;动态代理。</p>
<ul>
<li><p><strong>在Bean初始化阶段创建代理对象</strong>：Spring容器在初始化每个单例bean的时候，会遍历容器中的所有BeanPostProcessor实现类，并执行其postProcessAfterInitialization方法，在执行AbstractAutoProxyCreator类的postProcessAfterInitialization方法时会遍历容器中所有的切面，查找与当前实例化bean匹配的切面，这里会获取事务属性切面，查找@Transactional注解及其属性值，然后根据得到的切面创建一个代理对象，默认是使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。</p>
</li>
<li><p><strong>在执行目标方法时进行事务增强操作</strong>：当通过代理对象调用Bean方法的时候，会触发对应的AOP增强拦截器，声明式事务是一种环绕增强，对应接口为MethodInterceptor ，事务增强对该接口的实现为TransactionInterceptor ，类图如下：</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251214333.png">事务拦截器 TransactionInterceptor 在 invoke 方法中，通过调用父类TransactionAspectSupport 的 invokeWithinTransaction 方法进行事务处理，包括开启事务、事务提交、异常回滚。</p>
</li>
</ul>
<h2 id="声明式事务在哪些情况下会失效？"><a href="#声明式事务在哪些情况下会失效？" class="headerlink" title="声明式事务在哪些情况下会失效？"></a>声明式事务在哪些情况下会失效？</h2><p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251216988.png"></p>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="Spring-MVC-的核心组件？"><a href="#Spring-MVC-的核心组件？" class="headerlink" title="Spring MVC 的核心组件？"></a><strong>Spring MVC</strong> 的核心组件？</h2><p><strong>1.</strong> DispatcherServlet ：前置控制器，是整个流程控制的 核心 ，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</p>
<p><strong>2.</strong> Handler ：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</p>
<p><strong>3.</strong> HandlerMapping ：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</p>
<p><strong>4.</strong> HandlerInterceptor ：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</p>
<p><strong>5.</strong> HandlerExecutionChain ：处理器执行链，包括两部分内容：Handler 和HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</p>
<p><strong>6.</strong> HandlerAdapter ：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</p>
<p><strong>7.</strong> ModelAndView ：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</p>
<p><strong>8.</strong> ViewResolver ：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端</p>
<h2 id="Spring-MVC-的工作流程？"><a href="#Spring-MVC-的工作流程？" class="headerlink" title="Spring MVC 的工作流程？"></a><strong>Spring MVC</strong> 的工作流程？</h2><p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251219781.png"></p>
<p><strong>1.</strong> 客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。</p>
<p><strong>2.</strong> DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）</p>
<p><strong>3.</strong> DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</p>
<p><strong>4.</strong> HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet</p>
<p><strong>5.</strong> DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。</p>
<p><strong>6.</strong> DispatcherServlet将模型数据填充到视图中</p>
<p><strong>7.</strong> DispatcherServlet将结果响应给客户端</p>
<p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有 <strong>Handler</strong>（<strong>Controller</strong>） 、<strong>View</strong> 、<strong>Model</strong>。</p>
<p>当然我们现在大部分的开发都是前后端分离，Restful风格接口，后端只需要返回Json数据就行了。</p>
<h2 id="SpringMVC-Restful风格的接口的流程是什么样的呢？"><a href="#SpringMVC-Restful风格的接口的流程是什么样的呢？" class="headerlink" title="SpringMVC Restful风格的接口的流程是什么样的呢？"></a><strong>SpringMVC Restful</strong>风格的接口的流程是什么样的呢？</h2><p>我们都知道Restful接口，响应格式是json，这就用到了一个常用注解：</p>
<p><strong>@ResponseBody</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入了这个注解后，整体的流程上和使用ModelAndView大体上相同，但是细节上有一些不同：</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251222415.png"></p>
<p><strong>1.</strong> 客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet</p>
<p><strong>2.</strong> DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理</p>
<p><strong>3.</strong> DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</p>
<p><strong>4.</strong> Controller被封装成了ServletInvocableHandlerMethod，HandlerAdapter处理器适配器去执行invokeAndHandle方法，完成对Controller的请求处理</p>
<p><strong>5.</strong> HandlerAdapter执行完对Controller的请求，会调HandlerMethodReturnValueHandler去处理返回值，主要的过程：</p>
<p>5.1. 调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例</p>
<p>5.2.使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中</p>
<p>5.3.在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化</p>
<p><strong>6.</strong> 执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已</p>
<p>经写入了响应，所以不用关心View的处理</p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a><strong>Spring Boot</strong></h1><h2 id="介绍一下SpringBoot，有哪些优点？"><a href="#介绍一下SpringBoot，有哪些优点？" class="headerlink" title="介绍一下SpringBoot，有哪些优点？"></a>介绍一下<strong>SpringBoot</strong>，有哪些优点？</h2><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p>
<p>Spring Boot 以 约定大于配置 核心思想开展工作，相比Spring具有如下优势：</p>
<p><strong>1.</strong> Spring Boot 可以快速创建独立的Spring应用程序。</p>
<p><strong>2.</strong> Spring Boot 内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</p>
<p><strong>3.</strong> Spring Boot 无需再像Spring一样使用一堆繁琐的xml文件配置。</p>
<p><strong>4.</strong> Spring Boot 可以自动配置(核心)Spring。SpringBoot将原有的XML配置改为Java配置，将bean注入改为使用注解注入的方式(@Autowire)，并将多个xml、properties配置浓缩在一个appliaction.yml配置文件中。</p>
<p><strong>5.</strong> Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。</p>
<p><strong>6.</strong> Spring Boot 可以快速整合常用依赖（开发库，例如spring-webmvc、jackson-json、validation-api和tomcat等），提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自引入其他依赖。</p>
<h2 id="SpringBoot自动配置原理了解吗"><a href="#SpringBoot自动配置原理了解吗" class="headerlink" title="SpringBoot自动配置原理了解吗"></a><strong>SpringBoot</strong>自动配置原理了解吗</h2><p>SpringBoot开启自动配置的注解是 @EnableAutoConfiguration ，启动类上的注解 @SpringBootApplication 是一个复合注解，包含了@EnableAutoConfiguration：</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251228002.png"></p>
<ul>
<li><p>EnableAutoConfiguration 只是一个简单的注解，自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//将main同级的包下的所有组件注册到容器</span></span><br><span class="line">中</span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动</span></span><br><span class="line">装配类 xxxAutoconfiguration</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span></span><br><span class="line"><span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AutoConfigurationImportSelector 实现了 ImportSelector 接口，这个接口的作用就是收集需要导入的配置类，配合 @Import(） 就可以将相应的类导入到Spring容器中</p>
</li>
<li><p>获取注入类的方法是selectImports()，它实际调用的是getAutoConfigurationEntry ，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：</p>
<p><strong>1.</strong> 获取注解的属性，用于后面的排除</p>
<p><strong>2.</strong> 获取所有需要自动装配的配置类的路径 ：这一步是最关键的，从META-INF&#x2F;spring.factories获取自动配置类的路径</p>
<p><strong>3.</strong> 去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来</p>
</li>
</ul>
<h2 id="如何自定义一个SpringBoot-Srarter"><a href="#如何自定义一个SpringBoot-Srarter" class="headerlink" title="如何自定义一个SpringBoot Srarter?"></a>如何自定义一个<strong>SpringBoot Srarter?</strong></h2><p>知道了自动配置原理，创建一个自定义SpringBoot Starter也很简单。</p>
<p><strong>1.</strong> 创建一个项目，命名为demo-spring-boot-starter，引入SpringBoot相关依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configurationprocessor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> 编写配置文件</p>
<p>这里定义了属性配置的前缀</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProperties</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//省略getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> 自动装配</p>
<p>创建自动配置类HelloPropertiesConfigure</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloPropertiesConfigure</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> 配置自动类</p>
<p>在 &#x2F;resources&#x2F;META-INF&#x2F;spring.factories 文件中添加自动配置类路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfigura</span><br><span class="line">tion=\</span><br><span class="line">cn.fighter3.demo.starter.configure.HelloPropertiesConfigur</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<h2 id="Springboot-启动原理？"><a href="#Springboot-启动原理？" class="headerlink" title="Springboot 启动原理？"></a><strong>Springboot</strong> 启动原理？</h2><p>SpringApplication 这个类主要做了以下四件事情：</p>
<p><strong>1.</strong> 推断应用的类型是普通的项目还是 Web 项目</p>
<p><strong>2.</strong> 查找并加载所有可用初始化器 ， 设置到 initializers 属性中</p>
<p><strong>3.</strong> 找出所有的应用程序监听器，设置到 listeners 属性中</p>
<p><strong>4.</strong> 推断并设置 main 方法的定义类，找到运行的主类</p>
<p>SpringBoot 启动大致流程如下 ：</p>
<p><img data-src="https://andornot.oss-cn-hangzhou.aliyuncs.com/imgs/202305251237060.png"></p>

      </div>
      
      
      
    </div>
  <ul class="breadcrumb">
            <li><a href="/way/">面试宝典</a></li>
            <li><a href="/way/framework/">开发框架</a></li>
          <li>SPRING</li>
  </ul>

    
    


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">与或非</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">38k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/andornottop" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":"faltruese","home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://andornot.top/way/framework/spring/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
