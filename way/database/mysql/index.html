<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_non1200.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_non1200.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_non1200.png">
  <link rel="mask-icon" href="/images/logo_and.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"andornot.top","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础什么是内连接、外连接、交叉连接、笛卡尔积呢？ 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。  外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。  交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么">
<meta property="og:type" content="blog">
<meta property="og:title" content="mysql">
<meta property="og:url" content="https://andornot.top/way/database/mysql/index.html">
<meta property="og:site_name" content="与或非&#39;s Blog">
<meta property="og:description" content="基础什么是内连接、外连接、交叉连接、笛卡尔积呢？ 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。  外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。  交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://andornot.top/pics/index.assets/202305252134303.png">
<meta property="og:image" content="https://andornot.top/pics/index.assets/202305252136420.png">
<meta property="og:image" content="https://andornot.top/pics/index.assets/202305252218961.png">
<meta property="og:image" content="https://andornot.top/pics/index.assets/202305252222310.png">
<meta property="og:image" content="https://andornot.top/pics/index.assets/202305252259379.png">
<meta property="og:image" content="https://andornot.top/pics/index.assets/202305252308485.png">
<meta property="og:image" content="https://andornot.top/pics/index.assets/202305271933035.png">
<meta property="article:published_time" content="2023-04-12T14:33:52.000Z">
<meta property="article:modified_time" content="2023-05-28T06:45:16.771Z">
<meta property="article:author" content="与或非">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://andornot.top/pics/index.assets/202305252134303.png">


<link rel="canonical" href="https://andornot.top/way/database/mysql/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://andornot.top/way/database/mysql/index.html","path":"way/database/mysql/index.html","title":"mysql"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>mysql | 与或非's Blog
</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">与或非's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-面试宝典"><a href="/way/" rel="section"><i class="fa fa-flag fa-fw"></i>面试宝典</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E3%80%81%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E5%91%A2%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">什么是内连接、外连接、交叉连接、笛卡尔积呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%9A%84%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%9C%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">MySQL 的内连接、左连接、右连接有有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">说一下数据库的三大范式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#varchar%E4%B8%8Echar%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">varchar与char的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">一条SQL查询语句的执行顺序？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据库架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-MySQL-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">说说 MySQL 的基础架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1-SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-MySQL-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">一条 SQL 查询语句在 MySQL 中如何执行的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">3.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">MySQL有哪些常见存储引擎？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">4.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">MySQL日志文件有哪些？分别介绍下作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binlog%E5%92%8Credo-log%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">binlog和redo log有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">一条更新语句怎么执行的了解吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL-%E4%BC%98%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">SQL 优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%85%A2SQL%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%91%A2%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">慢SQL如何定位呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E4%BC%98%E5%8C%96%E6%85%A2SQL%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">有哪些方式优化慢SQL？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%88explain%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%85%B6%E4%B8%AD%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">怎么看执行计划（explain），如何理解其中各个字段的含义？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">6.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E5%90%97%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">能简单说一下索引的分类吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%8A%A0%E5%BF%AB%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">为什么使用索引会加快查询？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F"><span class="nav-number">6.3.</span> <span class="nav-text">创建索引有哪些注意点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88%E5%91%A2%EF%BC%9F"><span class="nav-number">6.4.</span> <span class="nav-text">索引哪些情况下会失效呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8D%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E5%91%A2%EF%BC%9F"><span class="nav-number">6.5.</span> <span class="nav-text">索引不适合哪些场景呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">6.6.</span> <span class="nav-text">MySQL索引用的什么数据结构了解吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.7.</span> <span class="nav-text">聚簇索引与非聚簇索引的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">6.8.</span> <span class="nav-text">回表了解吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">6.9.</span> <span class="nav-text">覆盖索引了解吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%8C%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">MySQL中有哪几种锁，列举一下？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4InnoDB%E9%87%8C%E7%9A%84%E8%A1%8C%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.</span> <span class="nav-text">说说InnoDB里的行锁实现?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="nav-number">7.3.</span> <span class="nav-text">意向锁是什么知道吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">7.4.</span> <span class="nav-text">MySQL的乐观锁和悲观锁了解吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">8.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">MySQL 事务的四大特性说一下？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%A3ACID%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">那ACID靠什么保证的呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FMySQL-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">8.4.</span> <span class="nav-text">讲一下死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB%EF%BC%8C%E8%84%8F%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%91%A2%EF%BC%9F"><span class="nav-number">8.5.</span> <span class="nav-text">什么是幻读，脏读，不可重复读呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%90%84%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">8.6.</span> <span class="nav-text">事务的各个隔离级别都是如何实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">8.7.</span> <span class="nav-text">MVCC了解吗？怎么实现的？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="与或非"
      src="/images/logo_head300.png">
  <p class="site-author-name" itemprop="name">与或非</p>
  <div class="site-description" itemprop="description">个人成长记录与分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/andornottop" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;andornottop" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:andornottop@163.com" title="E-Mail → mailto:andornottop@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner page posts-expand">
    <ul class="sub-menu menu">
      
  <li class="menu-item menu-item-计算机基础"><a href="/way/base/" rel="section"><i class="fa fa-code fa-fw"></i>计算机基础</a></li>


      
  <li class="menu-item menu-item-java"><a href="/way/java/" rel="section"><i class="fa fa-mug-hot fa-fw"></i>Java</a></li>


      
  <li class="menu-item menu-item-开发框架"><a href="/way/framework/" rel="section"><i class="fa fa-cube fa-fw"></i>开发框架</a></li>


      
  <li class="menu-item menu-item-数据存储"><a href="/way/database/" rel="section"><i class="fa fa-database fa-fw"></i>数据存储</a></li>


      
  <li class="menu-item menu-item-消息队列"><a href="/way/mq/" rel="section"><i class="fa fa-random fa-fw"></i>消息队列</a></li>


      
  <li class="menu-item menu-item-devops"><a href="/way/devops/" rel="section"><i class="fa fa-code-branch fa-fw"></i>DevOps</a></li>


    </ul>
    <ul class="sub-menu menu">
      
  <li class="menu-item menu-item-mysql"><a href="/way/database/mysql/" rel="section"><i class="fa fa-table fa-fw"></i>MySQL</a></li>


      
  <li class="menu-item menu-item-redis"><a href="/way/database/redis/" rel="section"><i class="fa fa-columns fa-fw"></i>Redis</a></li>


      
  <li class="menu-item menu-item-elasticsearch"><a href="/way/database/elasticsearch/" rel="section"><i class="fa fa-binoculars fa-fw"></i>Elasticsearch</a></li>


    </ul>


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header">

<h1 class="post-title" itemprop="name headline">mysql
</h1>

<div class="post-meta-container">
  <ul class="breadcrumb">
            <li><a href="/way/">面试宝典</a></li>
            <li><a href="/way/database/">数据存储</a></li>
          <li>MYSQL</li>
  </ul>
</div>

</header>

      
      
      <div class="post-body">
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="什么是内连接、外连接、交叉连接、笛卡尔积呢？"><a href="#什么是内连接、外连接、交叉连接、笛卡尔积呢？" class="headerlink" title="什么是内连接、外连接、交叉连接、笛卡尔积呢？"></a>什么是内连接、外连接、交叉连接、笛卡尔积呢？</h2><ul>
<li><p>内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。</p>
</li>
<li><p>外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。</p>
</li>
<li><p>交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B交叉连接的结果就有m*n行。</p>
</li>
</ul>
<p>笛卡尔积：是数学中的一个概念，例如集合A&#x3D;{a,b}，集合B&#x3D;{1,2,3}，那么</p>
<p>A✖ B&#x3D;{&lt;a,o&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;,}。</p>
<h2 id="MySQL-的内连接、左连接、右连接有有什么区别？"><a href="#MySQL-的内连接、左连接、右连接有有什么区别？" class="headerlink" title="MySQL 的内连接、左连接、右连接有有什么区别？"></a><strong>MySQL</strong> 的内连接、左连接、右连接有有什么区别？</h2><p>MySQL的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。</p>
<ul>
<li><p>inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集。</p>
</li>
<li><p>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</p>
</li>
<li><p>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</p>
</li>
</ul>
<h2 id="说一下数据库的三大范式？"><a href="#说一下数据库的三大范式？" class="headerlink" title="说一下数据库的三大范式？"></a>说一下数据库的三大范式？</h2><p>第一范式：数据表中的每一列（每个字段）都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。</p>
<h2 id="varchar与char的区别？"><a href="#varchar与char的区别？" class="headerlink" title="varchar与char的区别？"></a><strong>varchar</strong>与<strong>char</strong>的区别？</h2><p><strong>char</strong>：</p>
<ul>
<li><p>char表示定长字符串，长度是固定的；</p>
</li>
<li><p>如果插入数据的长度小于char的固定长度时，则用空格填充；</p>
</li>
<li><p>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</p>
</li>
<li><p>对于char来说，最多能存放的字符个数为255，和编码无关</p>
</li>
</ul>
<p><strong>varchar</strong>：</p>
<ul>
<li><p>varchar表示可变长字符串，长度是可变的；</p>
</li>
<li><p>插入的数据是多长，就按照多长来存储；</p>
</li>
<li><p>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</p>
</li>
<li><p>对于varchar来说，最多能存放的字符个数为65532</p>
</li>
</ul>
<p>日常的设计，对于长度相对固定的字符串，可以使用char，对于长度不确定的，使用</p>
<p>varchar更合适一些。</p>
<h2 id="一条SQL查询语句的执行顺序？"><a href="#一条SQL查询语句的执行顺序？" class="headerlink" title="一条SQL查询语句的执行顺序？"></a>一条<strong>SQL</strong>查询语句的执行顺序？</h2><p><img data-src="/pics/index.assets/202305252134303.png"></p>
<p><strong>1.</strong> FROM ：对FROM子句中的左表<left_table>和右表<right_table>执行笛卡儿积（Cartesianproduct），产生虚拟表VT1</p>
<p><strong>2.</strong> ON ：对虚拟表VT1应用ON筛选，只有那些符合<join_condition>的行才被插入虚拟表VT2中</p>
<p><strong>3.</strong> JOIN ：如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）～步骤3），直到处理完所有的表为止</p>
<p><strong>4.</strong> WHERE ：对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才被插入虚拟表VT4中</p>
<p><strong>5.</strong> GROUP BY ：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5</p>
<p><strong>6.</strong> CUBE|ROLLUP ：对表VT5进行CUBE或ROLLUP操作，产生表VT6</p>
<p><strong>7.</strong> HAVING ：对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才被插入虚拟表VT7中。</p>
<p><strong>8.</strong> SELECT ：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中</p>
<p><strong>9.</strong> DISTINCT ：去除重复数据，产生虚拟表VT9</p>
<p><strong>10.</strong> ORDER BY ：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10。11）</p>
<p><strong>11.</strong> LIMIT ：取出指定行的记录，产生虚拟表VT11，并返回给查询用户</p>
<h1 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h1><h2 id="说说-MySQL-的基础架构"><a href="#说说-MySQL-的基础架构" class="headerlink" title="说说 MySQL 的基础架构"></a>说说 <strong>MySQL</strong> 的基础架构</h2><p><img data-src="/pics/index.assets/202305252136420.png"></p>
<p>MySQL逻辑架构图主要分三层：</p>
<ul>
<li><p>客户端：最上层的服务并不是MySQL所独有的，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</p>
</li>
<li><p>Server层：大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</p>
</li>
<li><p>存储引擎层：第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。Server层通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。</p>
</li>
</ul>
<h2 id="一条-SQL-查询语句在-MySQL-中如何执行的？"><a href="#一条-SQL-查询语句在-MySQL-中如何执行的？" class="headerlink" title="一条 SQL 查询语句在 MySQL 中如何执行的？"></a>一条 <strong>SQL</strong> 查询语句在 <strong>MySQL</strong> 中如何执行的？</h2><ul>
<li><p>先检查该语句 是否有权限 ，如果没有权限，直接返回错误信息，如果有权限会先查询缓存 (MySQL8.0 版本以前)。</p>
</li>
<li><p>如果没有缓存，分析器进行 语法分析 ，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。</p>
</li>
<li><p>语法解析之后，MySQL的服务器会对查询的语句进行优化，确定执行的方案。完成查询优化后，按照生成的执行计划 调用数据库引擎接口 ，返回执行结果。</p>
</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MySQL有哪些常见存储引擎？"><a href="#MySQL有哪些常见存储引擎？" class="headerlink" title="MySQL有哪些常见存储引擎？"></a><strong>MySQL</strong>有哪些常见存储引擎？</h2><p>常用引擎包括：MYISAM、Innodb、Memory、MERGE</p>
<ul>
<li>MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎。</li>
<li>Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些。</li>
<li>Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变化不频繁的代码表。</li>
<li>MERGE：是一组MYISAM表的组合</li>
</ul>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="MySQL日志文件有哪些？分别介绍下作用？"><a href="#MySQL日志文件有哪些？分别介绍下作用？" class="headerlink" title="MySQL日志文件有哪些？分别介绍下作用？"></a><strong>MySQL</strong>日志文件有哪些？分别介绍下作用？</h2><p>MySQL日志文件有很多，包括 ：</p>
<ul>
<li><p>错误日志 （error log）：错误日志文件对MySQL的启动、运行、关闭过程进行了记录，能帮助定位MySQL问题。</p>
</li>
<li><p>慢查询日志 （slow query log）：慢查询日志是用来记录执行时间超过long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。</p>
</li>
<li><p>一般查询日志 （general log）：一般查询日志记录了所有对MySQL数据库请求的信息，无论请求是否正确执行。</p>
</li>
<li><p>二进制日志 （bin log）：关于二进制日志，它记录了数据库所有执行的DDL和DML语句（除了数据查询语句select、show等），以事件形式记录并保存在二进制文件中。</p>
</li>
</ul>
<p>还有两个InnoDB存储引擎特有的日志文件：</p>
<ul>
<li><p>重做日志 （redo log）：重做日志至关重要，因为它们记录了对于InnoDB存储引擎的事务日志。</p>
</li>
<li><p>回滚日志 （undo log）：回滚日志同样也是InnoDB引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
</li>
</ul>
<h2 id="binlog和redo-log有什么区别？"><a href="#binlog和redo-log有什么区别？" class="headerlink" title="binlog和redo log有什么区别？"></a><strong>binlog</strong>和<strong>redo log</strong>有什么区别？</h2><ul>
<li><p>bin log会记录所有与数据库有关的日志记录，包括InnoDB、MyISAM等存储引擎的日志，而redo log只记InnoDB存储引擎的日志。</p>
</li>
<li><p>记录的内容不同，bin log记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而redo log记录的是关于每个页（Page）的更改的物理情况。</p>
</li>
<li><p>写入的时间不同，bin log仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有redo ertry被写入redo log中。</p>
</li>
<li><p>写入的方式也不相同，redo log是循环写入和擦除，bin log是追加写入，不会覆盖已经写的文件</p>
</li>
</ul>
<h2 id="一条更新语句怎么执行的了解吗？"><a href="#一条更新语句怎么执行的了解吗？" class="headerlink" title="一条更新语句怎么执行的了解吗？"></a>一条更新语句怎么执行的了解吗？</h2><p>更新语句的执行是Server层和引擎层配合完成，数据除了要写入表中，还要记录相应的日志。</p>
<p><img data-src="/pics/index.assets/202305252218961.png"></p>
<p><strong>1.</strong> 执行器先找引擎获取ID&#x3D;2这一行。ID是主键，存储引擎检索数据，找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
<p><strong>2.</strong> 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
<p><strong>3.</strong> 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p>
<p><strong>4.</strong> 执行器生成这个操作的binlog，并把binlog写入磁盘。</p>
<p><strong>5.</strong> 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</p>
<p>从上图可以看出，MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。</p>
<p>不仅如此，在对redo log写入时有两个阶段的提交，一是binlog写入之前 prepare 状态的写入，二是binlog写入之后 commit 状态的写入。</p>
<h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a><strong>SQL</strong> 优化</h1><h2 id="慢SQL如何定位呢？"><a href="#慢SQL如何定位呢？" class="headerlink" title="慢SQL如何定位呢？"></a>慢<strong>SQL</strong>如何定位呢？</h2><ul>
<li><p>慢查询日志 ：开启MySQL的慢查询日志，再通过一些工具比如mysqldumpslow去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。</p>
</li>
<li><p>服务监控 ：可以在业务的基建中加入对慢SQL的监控，常见的方案有字节码插桩、连接池扩展、ORM框架过程，对服务运行中的慢SQL进行监控和告警。</p>
</li>
</ul>
<h2 id="有哪些方式优化慢SQL？"><a href="#有哪些方式优化慢SQL？" class="headerlink" title="有哪些方式优化慢SQL？"></a>有哪些方式优化慢<strong>SQL</strong>？</h2><p>慢SQL的优化，主要从两个方面考虑，SQL语句本身的优化，以及数据库设计的优化。</p>
<p><img data-src="/pics/index.assets/202305252222310.png"></p>
<ul>
<li><p><strong>避免不必要的列</strong></p>
<p>这个是老生常谈，但还是经常会出的情况，SQL查询的时候，应该只查询需要的列，而不要包含额外的列，像 slect * 这种写法应该尽量避免。</p>
</li>
<li><p><strong>分页优化</strong></p>
</li>
<li><p><strong>索引优化</strong></p>
<p>合理地设计和使用索引，是优化慢SQL的利器。</p>
<ul>
<li><p><strong>利用覆盖索引</strong></p>
<p>InnoDB使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引。</p>
<p>例如对于如下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> test <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;上海&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> index idx_city_name (city, name);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>低版本避免使用or查询</strong></p>
<p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。</p>
</li>
<li><p><strong>避免使用 !&#x3D; 或者 &lt;&gt; 操作符</strong></p>
<p>SQL中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引。</p>
<p>解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描</p>
<p>例如，把 column&lt;&gt;’aaa’，改成column&gt;’aaa’ or column&lt;’aaa’ ，就可以使用索引了</p>
</li>
<li><p><strong>适当使用前缀索引</strong></p>
<p>适当地使用前缀所云，可以降低索引的空间占用，提高索引的查询效率。</p>
<p>比如，邮箱的后缀都是固定的“ @xxx.com ”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>PS:需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引。</p>
</li>
<li><p><strong>避免列上函数运算</strong></p>
<p>要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率。</p>
</li>
<li><p><strong>正确使用联合索引</strong></p>
<p>使用联合索引的时候，注意最左匹配原则。</p>
</li>
</ul>
</li>
<li><p><strong>JOIN优化</strong></p>
<ul>
<li><p><strong>优化子查询</strong></p>
<p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大。</p>
</li>
<li><p><strong>小表驱动大表</strong></p>
<p>关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL内部会遍历驱动表，再去连接被驱动表。</p>
<p>比如left join，左表就是驱动表，A表小于B表，建立连接的次数就少，查询速度就被加快了。</p>
</li>
<li><p><strong>适当增加冗余字段</strong></p>
<p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略。</p>
</li>
<li><p><strong>避免使用JOIN关联太多的表</strong></p>
<p>《阿里巴巴Java开发手册》规定不要join超过三张表，第一join太多降低查询的速度，第二join的buffer会占用更多的内存。</p>
<p>如果不可避免要join多张表，可以考虑使用数据异构的方式异构到ES中查询。</p>
</li>
</ul>
</li>
<li><p><strong>排序优化</strong></p>
<ul>
<li><p><strong>利用索引扫描做排序</strong></p>
<p>MySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。</p>
<p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢。</p>
<p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建立索引（date,staff_id,customer_id）</span></span><br><span class="line"><span class="keyword">select</span> staff_id, customer_id <span class="keyword">from</span> test <span class="keyword">where</span> <span class="type">date</span> <span class="operator">=</span> <span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> staff_id,customer_id;</span><br></pre></td></tr></table></figure>

<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序。</p>
</li>
</ul>
</li>
<li><p><strong>UNION优化</strong></p>
<ul>
<li><p><strong>条件下推</strong></p>
<p>MySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引</p>
<p>最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化。</p>
<p>此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，</p>
<p>MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高。</p>
</li>
</ul>
</li>
</ul>
<h2 id="怎么看执行计划（explain），如何理解其中各个字段的含义？"><a href="#怎么看执行计划（explain），如何理解其中各个字段的含义？" class="headerlink" title="怎么看执行计划（explain），如何理解其中各个字段的含义？"></a>怎么看执行计划（<strong>explain</strong>），如何理解其中各个字段的含义？</h2><p>explain是sql优化的利器，除了优化慢sql，平时的sql编写，也应该先explain，查看一下执行计划，看看是否还有优化的空间。</p>
<p>直接在 select 语句之前增加 explain 关键字，就会返回执行计划的信息。</p>
<p><img data-src="/pics/index.assets/202305252259379.png"></p>
<p><strong>1.</strong> <strong>id</strong> 列：MySQL会为每个select语句分配一个唯一的id值</p>
<p><strong>2.</strong> <strong>select_type</strong> 列，查询的类型，根据关联、union、子查询等等分类，常见的查询类型有SIMPLE、PRIMARY。</p>
<p><strong>3.</strong> <strong>table</strong> 列：表示 explain 的一行正在访问哪个表。</p>
<p><strong>4.</strong> <strong>type</strong> 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。</p>
<p>性能从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt;index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<ul>
<li><p>system</p>
<p>当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快</p>
</li>
<li><p>const</p>
<p>表示查询时命中 primary key 主键或者 unique 唯一索引，或者被连接的部分是一个常量( const )值。这类扫描效率极高，返回数据量少，速度非常快。</p>
</li>
<li><p>eq_ref</p>
<p>查询时命中主键 primary key 或者 unique key 索引， type就是 eq_ref 。</p>
</li>
<li><p>ref_or_null</p>
<p>这种连接类型类似于 ref，区别在于 MySQL 会额外搜索包含 NULL 值的行。</p>
</li>
<li><p>index_merge </p>
<p>使用了索引合并优化方法，查询使用了两个以上的索引。</p>
</li>
<li><p>unique_subquery</p>
<p>替换下面的 IN 子查询，子查询返回不重复的集合。</p>
</li>
<li><p>index_subquery</p>
<p>区别于 unique_subquery ，用于非唯一索引，可以返回重复值。</p>
</li>
<li><p>range</p>
<p>使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在 where 语句中使用bettween…and 、 &lt; 、 &gt; 、 &lt;&#x3D; 、 in 等条件查询 type 都是 range 。</p>
</li>
<li><p>index</p>
<p>Index 与 ALL 其实都是读全表，区别在于 index 是遍历索引树读取，而 ALL 是从硬盘中读取。</p>
</li>
<li><p>ALL</p>
<p>就不用多说了，全表扫描。</p>
</li>
</ul>
<p><strong>5.</strong> <strong>possible_keys</strong> 列：显示查询可能使用哪些索引来查找，使用索引优化sql的时候比较重要。</p>
<p><strong>6.</strong> <strong>key</strong> 列：这一列显示 mysql 实际采用哪个索引来优化对该表的访问，判断索引是否失效的时候常用。</p>
<p><strong>7.</strong> <strong>key_len</strong> 列：显示了 MySQL使用</p>
<p><strong>8.</strong> <strong>ref</strong> 列：ref 列展示的就是与索引列作等值匹配的值，常见的有：const（常量），func，NULL，字段名。</p>
<p><strong>9.</strong> <strong>rows</strong> 列：这也是一个重要的字段，MySQL查询优化器根据统计信息，估算SQL要查到结果集需要扫描读取的数据行数，这个值非常直观显示SQL的效率好坏，原则上rows越少越好。</p>
<p><strong>10.</strong> <strong>Extra</strong> 列：显示不适合在其它列的额外信息，虽然叫额外，但是也有一些重要的信息：</p>
<ul>
<li><p>Using index：表示MySQL将使用覆盖索引，以避免回表</p>
</li>
<li><p>Using where：表示会在存储引擎检索之后再进行过滤</p>
</li>
<li><p>Using temporary ：表示对查询结果排序时会使用一个临时表。</p>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="能简单说一下索引的分类吗？"><a href="#能简单说一下索引的分类吗？" class="headerlink" title="能简单说一下索引的分类吗？"></a>能简单说一下索引的分类吗？</h2><p>从三个不同维度对索引分类：</p>
<p><img data-src="/pics/index.assets/202305252308485.png"></p>
<p>例如从基本使用使用的角度来讲：</p>
<ul>
<li>主键索引: InnoDB主键是默认的索引，数据列不允许重复，不允许为NULL，一</li>
</ul>
<p>个表只能有一个主键。</p>
<ul>
<li>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索</li>
</ul>
<p>引。</p>
<ul>
<li><p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
</li>
<li><p>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</p>
</li>
</ul>
<h2 id="为什么使用索引会加快查询？"><a href="#为什么使用索引会加快查询？" class="headerlink" title="为什么使用索引会加快查询？"></a>为什么使用索引会加快查询？</h2><p>使用索引来快速定位符合查询条件的记录，并只检索必要的行和列以返回结果，从而不必进行全表扫描。并且索引是树形结构，查询时间通常与所需查找的行数呈对数关系，从而使查询变得更加高效。</p>
<p>举例来说，如果要在一个包含10000条记录的用户表中查找名字为“Tom”的用户信息，如果没有索引，那么数据库会逐行扫描表格，直到找到名字为“Tom”的用户信息；而如果有名字的索引，则数据库只需在索引结构中查找名为“Tom”的索引键值所对应的记录位置，然后再去表中取出相关的用户信息，查询速度会大大提升。</p>
<p>不过需要注意的是，虽然索引可以加快查询速度，但是索引建立也需要消耗一定的时间和存储空间，在对数据频繁进行增删改等操作时，可能会导致索引效率下降，因此需要根据实际情况合理使用索引。</p>
<h2 id="创建索引有哪些注意点？"><a href="#创建索引有哪些注意点？" class="headerlink" title="创建索引有哪些注意点？"></a>创建索引有哪些注意点？</h2><p><strong>1.</strong> 索引应该建在查询应用频繁的字段</p>
<p>在用于 where 判断、 order 排序和 join 的(on)字段上创建索引。</p>
<p><strong>2.</strong> 索引的个数应该适量</p>
<p>索引需要占用空间；更新时候也需要维护。</p>
<p><strong>3.</strong> 区分度低的字段，例如性别，不要建索引。</p>
<p>离散度太低的字段，扫描的行数降低的有限。</p>
<p><strong>4.</strong> 频繁更新的值，不要作为主键或者索引</p>
<p>维护索引文件需要成本；还会导致页分裂，IO次数增多。</p>
<p><strong>5.</strong> 组合索引把散列性高(区分度高)的值放在前面</p>
<p>为了满足最左前缀匹配原则</p>
<p><strong>6.</strong> 创建组合索引，而不是修改单列索引。</p>
<p>组合索引代替多个单列索引（对于单列索引，MySQL基本只能使用一个索引，所以经常使用多个条件查询时更适合使用组合索引）</p>
<p><strong>7.</strong> 过长的字段，使用前缀索引。</p>
<p>当字段值比较长的时候，建立索引会消耗很多的空间，搜索起来也会很慢。我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。</p>
<p><strong>8.</strong> 不建议用无序的值(例如身份证、UUID )作为索引</p>
<p>当主键具有不确定性，会造成叶子节点频繁分裂，出现磁盘存储的碎片化</p>
<h2 id="索引哪些情况下会失效呢？"><a href="#索引哪些情况下会失效呢？" class="headerlink" title="索引哪些情况下会失效呢？"></a>索引哪些情况下会失效呢？</h2><ul>
<li><p>查询条件包含or，可能导致索引失效</p>
</li>
<li><p>如果字段类型是字符串，where时一定用引号括起来，否则会因为隐式类型转换，索引失效</p>
</li>
<li><p>like通配符可能导致索引失效。</p>
</li>
<li><p>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</p>
</li>
<li><p>在索引列上使用mysql的内置函数，索引失效。</p>
</li>
<li><p>对索引列运算（如，+、-、*、&#x2F;），索引失效。</p>
</li>
<li><p>索引字段上使用（！&#x3D; 或者 &lt; &gt;，not in）时，可能会导致索引失效。</p>
</li>
<li><p>索引字段上使用is null， is not null，可能导致索引失效。</p>
</li>
<li><p>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</p>
</li>
<li><p>MySQL优化器估计使用全表扫描要比使用索引快,则不使用索引。</p>
</li>
</ul>
<h2 id="索引不适合哪些场景呢？"><a href="#索引不适合哪些场景呢？" class="headerlink" title="索引不适合哪些场景呢？"></a>索引不适合哪些场景呢？</h2><ul>
<li><p>数据量比较少的表不适合加索引</p>
</li>
<li><p>更新比较频繁的字段也不适合加索引</p>
</li>
<li><p>离散低的字段不适合加索引（如性别）</p>
</li>
</ul>
<h2 id="MySQL索引用的什么数据结构了解吗？"><a href="#MySQL索引用的什么数据结构了解吗？" class="headerlink" title="MySQL索引用的什么数据结构了解吗？"></a><strong>MySQL</strong>索引用的什么数据结构了解吗？</h2><p>MySQL的默认存储引擎是InnoDB，它采用的是B+树结构的索引。</p>
<p>B+树：只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</p>
<p>假设索引字段是 bigint 类型，长度为 8 字节。指针大小在 InnoDB 源码中设置为 6字节，这样一共 14 字节。非叶子节点(一页)可以存储 16384&#x2F;14&#x3D;1170 个这样的 单元(键值+指针)，代表有 1170 个指针。</p>
<p>树深度为 2 的时候，有 1170^2 个叶子节点，可以存储的数据1170*1170*16&#x3D;<strong>21902400</strong>。在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询数据最多需要访问 3 次磁盘。</p>
<p>所以在 InnoDB 中 B+ 树深度一般为 1-3 层，它就能满足千万级的数据存储。</p>
<h2 id="聚簇索引与非聚簇索引的区别？"><a href="#聚簇索引与非聚簇索引的区别？" class="headerlink" title="聚簇索引与非聚簇索引的区别？"></a>聚簇索引与非聚簇索引的区别？</h2><p>首先理解聚簇索引不是一种新的索引，而是而是一种数据存储方式。 聚簇表示数据行和相邻的键值紧凑地存储在一起。我们熟悉的两种存储引擎——MyISAM采用的是非聚簇索引，InnoDB采用的是聚簇索引。</p>
<ul>
<li><p>索引的数据结构是树，聚簇索引的索引和数据存储在一棵树上，树的叶子节点就是数据，非聚簇索引索引和数据不在一棵树上。</p>
</li>
<li><p>一个表中只能拥有一个聚簇索引，而非聚簇索引一个表可以存在多个。</p>
</li>
<li><p>聚簇索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p>
</li>
<li><p>聚簇索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</p>
</li>
</ul>
<h2 id="回表了解吗？"><a href="#回表了解吗？" class="headerlink" title="回表了解吗？"></a>回表了解吗？</h2><p>在InnoDB存储引擎里，利用辅助索引查询，先通过辅助索引找到主键索引的键值，再通过主键值查出主键索引里面没有符合要求的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。</p>
<h2 id="覆盖索引了解吗？"><a href="#覆盖索引了解吗？" class="headerlink" title="覆盖索引了解吗？"></a>覆盖索引了解吗？</h2><p>在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL中有哪几种锁，列举一下？"><a href="#MySQL中有哪几种锁，列举一下？" class="headerlink" title="MySQL中有哪几种锁，列举一下？"></a><strong>MySQL</strong>中有哪几种锁，列举一下？</h2><p><img data-src="/pics/index.assets/202305271933035.png"></p>
<p>如果按锁粒度划分，有以下3种：</p>
<ul>
<li><p>表锁： 开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低；不会出现死锁。</p>
</li>
<li><p>行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</p>
</li>
<li><p>页锁： 开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</p>
</li>
</ul>
<p>如果按照兼容性，有两种：</p>
<ul>
<li><p>共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。</p>
</li>
<li><p>排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。</p>
</li>
</ul>
<h2 id="说说InnoDB里的行锁实现"><a href="#说说InnoDB里的行锁实现" class="headerlink" title="说说InnoDB里的行锁实现?"></a>说说<strong>InnoDB</strong>里的行锁实现?</h2><p>InnoDB使用行锁来实现并发控制，以保证事务的隔离性。行锁分为共享锁和排他锁。</p>
<ul>
<li>共享锁（S锁）允许多个事务同时持有同一行的共享锁，用于读操作。</li>
<li>排他锁（X锁）只允许一个事务持有该行的锁，用于写操作。</li>
</ul>
<p>在InnoDB中，行锁的实现是基于索引的，也就是说，如果没有命中索引，则会对整张表加锁。当事务需要获取某一行的锁时，会先判断是否已经被其他事务占用，如果没有则可以直接获取锁；如果已经被其他事务占用，则需要等待或者阻塞，直到该行的锁被释放。</p>
<p>在具体实现上，InnoDB使用两种锁算法：Record Lock和Gap Lock。</p>
<ul>
<li>Record Lock：指的是对某一行进行加锁，只有当其他事务尝试修改该行时，才会阻塞。Record Lock并不会对其他行造成阻塞。</li>
<li>Gap Lock：指的是对索引之间的间隙进行加锁，即使对已经不存在的行也会加锁。这是因为，在RR级别隔离下，如果不对间隙进行加锁，则可能出现幻读的情况。Gap Lock会对后续的插入造成阻塞，但不会对其他已经存在的行造成阻塞。</li>
</ul>
<p>需要注意的是，InnoDB在实现行锁时，并不是完全采用Record Lock和Gap Lock的方式，而是根据具体情况进行选择和优化。例如，在RR级别隔离下，如果某一事务使用了索引范围查询，则会自动升级为Gap Lock，以避免幻读的发生。</p>
<h2 id="意向锁是什么知道吗？"><a href="#意向锁是什么知道吗？" class="headerlink" title="意向锁是什么知道吗？"></a>意向锁是什么知道吗？</h2><p>意向锁（Intention Lock）是InnoDB中一种特殊的锁，用于协调多个事务对同一索引关键字的行进行加锁时的并发控制。</p>
<p>在InnoDB中，当一个事务需要对某个表的某行进行加锁时，需要先获取该行对应的索引上的意向锁。意向锁可以被多个事务同时持有，而且不会对其他事务造成阻塞。意向锁分为两种：</p>
<ul>
<li>意向共享锁（IS锁）：表示事务打算在该索引上加共享锁。</li>
<li>意向排他锁（IX锁）：表示事务打算在该索引上加排他锁。</li>
</ul>
<p>意向锁的作用是告诉其他事务，在该索引上已经有事务加了锁，如果要在该索引上加锁，就需要根据意向锁的类型来决定是加共享锁还是排他锁。这样可以避免多个事务同时对同一索引关键字的行进行加锁时出现死锁的情况。</p>
<p>需要注意的是，意向锁只对索引起作用，对于全表扫描不起作用。此外，意向锁与普通锁的区别在于，意向锁本身并不会导致其他事务被阻塞，而是通过提示其他事务是否需要加锁来实现并发控制。</p>
<h2 id="MySQL的乐观锁和悲观锁了解吗？"><a href="#MySQL的乐观锁和悲观锁了解吗？" class="headerlink" title="MySQL的乐观锁和悲观锁了解吗？"></a><strong>MySQL</strong>的乐观锁和悲观锁了解吗？</h2><ul>
<li>悲观锁 （Pessimistic Concurrency Control）：</li>
</ul>
<p>悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p>
<p>数据库中的行锁，表锁，读锁，写锁均为悲观锁。</p>
<ul>
<li>乐观锁（Optimistic Concurrency Control）</li>
</ul>
<p>乐观锁认为数据的变动不会太频繁。</p>
<p>乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。</p>
<p>事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本v1与数据中最新的版本v2相对比，如果v1&#x3D;v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时version会加1，以此来表明数据已被变动。如果，v1不等于v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="MySQL-事务的四大特性说一下？"><a href="#MySQL-事务的四大特性说一下？" class="headerlink" title="MySQL 事务的四大特性说一下？"></a><strong>MySQL</strong> 事务的四大特性说一下？</h2><ul>
<li><p>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p>
</li>
<li><p>一致性：指在事务开始之前和事务结束以后，数据不会被破坏，假如 A 账户给B 账户转 10 块钱，不管成功与否，A 和 B 的总金额是不变的。</p>
</li>
<li><p>隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是井水不犯河水的。</p>
</li>
<li><p>持久性：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</p>
</li>
</ul>
<h2 id="那ACID靠什么保证的呢？"><a href="#那ACID靠什么保证的呢？" class="headerlink" title="那ACID靠什么保证的呢？"></a>那<strong>ACID</strong>靠什么保证的呢？</h2><ul>
<li><p>事务的 隔离性 是通过数据库锁的机制实现的。</p>
</li>
<li><p>事务的 一致性 由undo log来保证：undo log是逻辑日志，记录了事务的insert、update、deltete操作，回滚的时候做相反的delete、update、insert操作来恢复数据。</p>
</li>
<li><p>事务的 原子性 和 持久性 由redo log来保证：redolog被称作重做日志，是物理日志，事务提交的时候，必须先将事务的所有日志写入redo log持久化，到事务的提交操作才算完成。</p>
</li>
</ul>
<h2 id="事务的隔离级别有哪些？MySQL-的默认隔离级别是什么？"><a href="#事务的隔离级别有哪些？MySQL-的默认隔离级别是什么？" class="headerlink" title="事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？"></a>事务的隔离级别有哪些？<strong>MySQL</strong> 的默认隔离级别是什么？</h2><ul>
<li><p>读未提交（Read Uncommitted）：事务中的修改对其他事务都是可见的，即一个事务可以读取另一个事务尚未提交的数据。该隔离级别会导致脏读（Dirty Read）。</p>
</li>
<li><p>读已提交（Read Committed）：事务中的修改只有在提交之后才对其他事务可见，即一个事务只能读取另一个事务已经提交的数据。该隔离级别会导致不可重复读（Non-Repeatable Read）。</p>
</li>
<li><p>可重复读（Repeatable Read）：在同一事务中，多次读取同一数据得到的结果始终一致，即一个事务执行期间，禁止其他事务修改正在访问的数据。该隔离级别会导致幻读（Phantom Read）。</p>
</li>
<li><p>串行化（Serializable）：最高的隔离级别，强制事务串行执行，避免了脏读、不可重复读和幻读问题，但会降低并发性能。</p>
</li>
</ul>
<p>MySQL的默认隔离级别是可重复读（Repeatable Read），也就是说，在MySQL中，如果不显式设置隔离级别，则默认采用可重复读隔离级别。</p>
<h2 id="讲一下死锁"><a href="#讲一下死锁" class="headerlink" title="讲一下死锁"></a>讲一下死锁</h2><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续执行下去。简单来说，就是两个或多个进程互相持有对方需要的资源，同时又等待对方释放资源，导致所有进程都无法继续执行下去。</p>
<p>为了避免死锁的发生，我们可以采取以下措施：</p>
<ol>
<li>避免多个线程同时持有多个资源，并且让每个线程按照同样的顺序请求资源，这样可以避免死锁的发生。</li>
<li>设置超时时间，当线程等待时间超过一定阈值时，就放弃等待并释放已经持有的资源。</li>
<li>使用资源分配图来检测死锁的发生，并采取相应的措施解除死锁。</li>
<li>使用锁粒度更细的锁，这样可以减少锁的竞争，从而减少死锁的可能性。</li>
</ol>
<h2 id="什么是幻读，脏读，不可重复读呢？"><a href="#什么是幻读，脏读，不可重复读呢？" class="headerlink" title="什么是幻读，脏读，不可重复读呢？"></a>什么是幻读，脏读，不可重复读呢？</h2><ul>
<li><p>脏读：一个事务修改了某个数据，但还没有提交，另一个事务读取了这个数据，此时就会出现脏读。脏读问题主要发生在读未提交隔离级别下。</p>
</li>
<li><p>不可重复读：通常是由于其他事务修改了满足查询条件的数据行导致的。例如，一个事务读取了某一条数据，另一个事务修改了该数据，然后第一个事务再次读取同样的数据时，会发现数据已经发生改变。</p>
</li>
<li><p>幻读：通常是由于其他事务插入或删除了满足查询条件的数据行导致的。例如，一个事务在读取某个范围内的数据时，另一个事务插入了一条符合条件的数据，第一个事务再次读取同样的范围时，会发现多了一条记录。</p>
</li>
</ul>
<p>不同的隔离级别，在并发事务下可能会发生的问题：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommited 读取未提交</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Read Commited 读取已提交</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Repeatable Read 可重复读</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>Serialzable 可串行化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="事务的各个隔离级别都是如何实现的？"><a href="#事务的各个隔离级别都是如何实现的？" class="headerlink" title="事务的各个隔离级别都是如何实现的？"></a>事务的各个隔离级别都是如何实现的？</h2><ul>
<li><p><strong>读未提交</strong></p>
<p>读未提交，就不用多说了，采取的是读不加锁原理。</p>
<ul>
<li>事务读不加锁，不阻塞其他事务的读和写</li>
<li>事务写阻塞其他事务写，但不阻塞其他事务读；</li>
</ul>
</li>
<li><p><strong>读取已提交&amp;可重复读</strong></p>
<p>读取已提交和可重复读级别利用了 ReadView 和 MVCC ，也就是每个事务只能读取它能看到的版本（ReadView）。</p>
<ul>
<li>READ COMMITTED：每次读取数据前都生成一个ReadView</li>
<li>REPEATABLE READ ： 在第一次读取数据时生成一个ReadView</li>
</ul>
</li>
<li><p><strong>串行化</strong></p>
<p>串行化的实现采用的是读写都加锁的原理。</p>
<p>串行化的情况下，对于同一行事务， 写 会加 写锁 ， 读 会加 读锁 。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
</li>
</ul>
<h2 id="MVCC了解吗？怎么实现的？"><a href="#MVCC了解吗？怎么实现的？" class="headerlink" title="MVCC了解吗？怎么实现的？"></a><strong>MVCC</strong>了解吗？怎么实现的？</h2><p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种用于数据库管理系统中实现并发控制的技术。该技术支持在一个事务正在进行修改时，其他事务仍然可以读取数据，并且保证了读取的数据不会被正在执行的事务修改，从而提高了数据库的并发性能。</p>
<p>MVCC的实现需要对每个数据行记录都维护多个版本，并为每个事务分配一个唯一的事务ID（Transaction ID，即XID）。在每个数据行记录上，都会有一个存储该行的创建版本号和删除版本号的字段，以及一个指向最新版本的指针。在MVCC中，只有创建版本号早于当前事务ID的版本才是可见的，也就是说，一个事务只能读取它开始之前已经存在的数据行或者是自己创建的数据行，而不能读取其他事务正在修改的数据行。</p>
<p>当一个事务需要读取某个数据行时，会首先检查这个数据行是否被其他事务锁定，如果没有被锁定，则会根据该数据行的版本信息和当前事务的ID来选择合适的版本。如果该数据行被其他事务锁定，则会等待锁释放或超时，避免产生死锁问题。</p>
<p>当一个事务修改某个数据行时，会创建一个新版本，并将新版本的创建版本号设置为当前事务ID，并将原数据行的删除版本号设置为当前事务ID。这样就可以确保其他事务读取到的是旧版本，同时也不会修改其他事务正在使用的版本。</p>
<p>需要注意的是，在MVCC中，每个版本的数据行都会占用一定的存储空间，因此在大量并发访问和更新数据时，需要考虑存储空间的使用情况。</p>

      </div>
      
      
      
    </div>
  <ul class="breadcrumb">
            <li><a href="/way/">面试宝典</a></li>
            <li><a href="/way/database/">数据存储</a></li>
          <li>MYSQL</li>
  </ul>

    
    


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">与或非</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">58k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:31</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/andornottop" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":"faltruese","home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://andornot.top/way/database/mysql/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
